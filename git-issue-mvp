#!/bin/bash


is_int() {
  [[ $1 =~ ^-?[0-9]+$ ]]
}


# Remote Protocol 
  # file://
  # path starting with / or not, ending with .git
  # git://
  # https://
  # ssh://
  # [user@]server: [^/]+@[^/]+: as an SSH URL
  # Git's disambiguation rules
  # 1. If the string contains a / before the :, it is never scp-like.
  # 2. On Windows, C:\, D:repo are never scp-like.
  # 3. For host:path, Git checks:
  #   host has no slashes
  #   host contains only hostname-legal characters
  #   path is not empty
  # 
is_git_scp_like_host_path() {
    local url="$1"
    local host path host_part

    # must contain exactly one colon (first colon matters)
    [[ "$url" == *:* ]] || return 1

    host_part="${url%%:*}"
    path="${url#*:}"

    # path must not be empty to be scp-like
    [[ -n "$path" ]] || return 1

    # reject if '/' appears before the colon
    [[ "$host_part" != */* ]] || return 1

    # strip optional user@ (take part after last @)
    host="${host_part##*@}"

    # host must be non-empty
    [[ -n "$host" ]] || return 1

    # hostname-legal characters: [A-Za-z0-9.-]+
    [[ "$host" =~ ^[A-Za-z0-9.-]+$ ]] || return 1

    # Windows drive-letter exclusion (only if running on Windows Git)
    # Safe to keep on Unix — it never triggers
    if [[ "$OSTYPE" == msys* || "$OSTYPE" == cygwin* ]]; then
        [[ ! "$host" =~ ^[A-Za-z]$ ]] || return 1
    fi

    return 0 # scp-like
}


safe_cd() {
    local path="$1"
    if [ ! -e "$path" ]; then
        echo "Issue worktree not yet initiated(.issues does not exist)" >&2
        echo "  - use 'git issue init' to create one" >&2
        return 1
    elif [ ! -d "$path" ]; then
        echo "Error: .issues is not a directory" >&2
        return 1
    elif [ ! -x "$path" ]; then
        echo "Error: Permission denied (no execute permission): $path" >&2
        return 1
    elif ! cd "$path" 2>&1; then
        echo "Error: Cannot cd to $path (unknown reason)" >&2
        return 1
    fi
    return 0
}

git_project_root() {
    git worktree list --porcelain |
    awk '$1=="worktree" { print $2; exit }'
    # You can use
    #   dirname "$(git rev-parse --git-common-dir)"
    # Testing
    #   if [ "$(git_project_root)" != "$(realpath $(dirname $(git rev-parse --git-common-dir)))" ]; then echo "alarm!"; fi
}

#GIT_ISSUE_DIR=".issues"
git_issue_worktree() {
  # shellcheck disable=SC2155
  local root="$(git_project_root)"
  issues_rootdir="$root/.issues" || { echo ""; return 1; }
  echo "$issues_rootdir"
}

issue_ref() {
  echo "refs/issues/latest"
}

remote_issue_ref() {
  local remote="$1"
  echo "refs/remotes/$remote/issues/latest"
}



issue_git() {
  #root="$(git_project_root)"
  wt="$(git_issue_worktree)"
  #git -C "$root/.issues" "$@"
  git -C "$wt" "$@"
}

git_issue_clone() {
  remote="$1"
  root="$(git_project_root)"
  #remote=$(git_issue_remote)
  remote=${remote:-$(resolve_issue_remote)}

  local wt
  wt=$(git_issue_worktree)

  local local_ref remote_ref
  local_ref=$(issue_ref)
  remote_ref=$(remote_issue_ref "$remote")

  # git fetch "${opts[@]}" "$remote" \
  #   "$(issue_ref):$(remote_issue_ref "$remote")"
  git fetch "$remote" \
    "$(issue_ref):$(remote_issue_ref "$remote")"

  #git worktree add .issues $remote/issues/latest && cd .issues && git update-ref "$local_ref" HEAD
  git worktree add .issues "$remote_ref" && cd .issues && git update-ref "$local_ref" HEAD &&  git update-ref "$local_ref" "$remote_ref"

  
}


git_issue_init() {
  root="$(git_project_root)"
  wt=$(git_issue_worktree)

  [ -d "$wt" ] && {
    echo ".issues already exists. Use the following to remove it"
    echo ""
    echo "  git worktree remove $wt"
    echo "  git update-ref -d $(issue_ref)"
    return 0
  }

  #remote="$1"
  remote=$(resolve_issue_remote)

  local wt
  wt=$(git_issue_worktree)

  local local_ref remote_ref
  local_ref="$(issue_ref)"
  remote_ref="$(remote_issue_ref "$remote")"

  echo ".issue/" >> "$root/.git/info/exclude"

  if git ls-remote --exit-code "$remote" "$local_ref" > /dev/null 2>&1; then
    # ref exists on the remote
    echo '!W: The reference '"$local_ref"' exists on the remote('"$remote"').'
    while true; do 
      read -p '  - Do you want to clone it? (Y/N)' ans 
      case "$ans" in
        [Yy])
          git_issue_clone "$remote"
          git config --local extensions.worktreeConfig true || echo 'FAILED: git config --local extensions.worktreeConfig true'
          cd $wt && {  git config --worktree advice.detachedHead false
          git config --worktree core.hooksPath /dev/null || echo 'FAILED: git config --worktree core.hooksPath /dev/null'
          
          echo ".local-repo-id" >> "$(git rev-parse --git-dir)/info/exclude"; }
          cd - 
          return
          ;;
        [Nn])
          break
          ;;
      esac
    done 
  fi
  
  

#: since git worktree add --orphan is used, no more needed?
#  if git rev-parse --verify HEAD >/dev/null 2>&1; then
#    has_commit=1
#  else
#    has_commit=0
#    echo "Needs at least one commit before git issue init"
#    return 0
#  fi
  

  # Create orphan detached worktree
  # git worktree add --detach "$root/.issues" 
  # cd "$root/.issues" || return 1

  tmp_ref="refs/issues/tmp/$(date +%s)-$$"
  #git worktree add --orphan -B temp_issues $root/.issues
  git worktree add --orphan -B $tmp_ref $root/.issues  

  mkdir -p $root/.issues/issues
  
  git config --local extensions.worktreeConfig true || echo 'FAILED: git config --local extensions.worktreeConfig true'
  cd $wt || { echo "failed to cd to issue worktree"; return 1; }
  git config --worktree advice.detachedHead false 
  git config --worktree core.hooksPath /dev/null || echo 'FAILED: git config --worktree core.hooksPath /dev/null'
  
  echo ".local-repo-id" >> "$(git rev-parse --git-dir)/info/exclude"
  cat > .gitignore <<'EOF'
# Ignore everything in issues/ except TEMPLATE.md 
.local-repo-id
EOF

  cat > TEMPLATE.md <<'EOF'
---
title:
type: bug|feature|task|meta
status: open|in-progress|closed
priority: P1|P2|P3
severity: critical|high|medium|low
---

## Description

## Steps to Reproduce

## Expected Behavior

## Notes
EOF

#  cp TEMPLATE.md .issues/TEMPLATE.md

#  cat > issues/0001.md <<'EOF'
#---
#title: Initial issue tracking setup
#type: meta
#priority: low
#---
#
#Issue tracking initialized.
#EOF

  git add .
  git commit -m "issue init: templates loaded"
  commit=$(git rev-parse HEAD)
  
  #git update-ref "$ISSUE_REF_PREFIX/$issue_id" 
  git update-ref refs/issues/latest $commit

  echo "Initialized issue tracking in .issues/"
  
  git checkout --detach
  #git branch -D temp_issues
  git branch -D $tmp_ref
  cd - || { echo "failed to restore the directory"; return 1; }
}

parse_issue_id() {
  local id=$1

  if [[ "$id" == *-* ]]; then

    # Normalize ID format
    id_left=${id%-*}
    id_right=${id#*-}
    #echo "$id_left" "$id_right"
    if [ "$id_left" = "$id_right" ]; then
      echo 'usage: git issue edit <id>'
      echo '  <id> should be alphbets-integers like PACMAN-0012, PACMAN-12, or PACMAN12'
      return 1
    fi

    if ! is_int "$id_right"; then
      echo 'usage: git issue edit <id>'
      echo '  <id> should be alphbets-integers like PACMAN-0012, PACMAN-12, or PACMAN12'
      return 1
    fi 
  else
    if [[ "$id" =~ ^([[:alpha:]]+)([[:digit:]]+)$ ]]; then
            id_left="${BASH_REMATCH[1]}"
            id_right="${BASH_REMATCH[2]}"
        else
            echo "usage: git issue edit <id>"
            echo '  <id> should be alphbets-integers like PACMAN-0012, PACMAN-12, or PACMAN12'
            return 1
        fi
    fi
    

  #echo "$id_left" "$id_right"
  id_right=$(sed 's/^0*//' <<< "$id_right")
  # 012은 octal number 12로 인식되므로 10진수로 바꿔줘야 함
  id_right=$(printf "%04d" "$id_right")
  #echo "$id_left" "$id_right"
  
  id="$id_left"-"$id_right"
  echo "$id"
}


git_issue_edit() {

  id="$(parse_issue_id "$1")" || return 1

  fn_md="$id".md
  root=$(git_project_root)
  wt=$(git_issue_worktree)
  path="$wt"/issues/"$fn_md"
  if ! safe_cd "$wt"; then
    return 1
  fi
  
  #fn=$1
  [ -z "$id" ] && { echo "usage: git issue edit <id>"; return 1; }

  # if ! is_int "$id"; then echo 'usage: git issue show <id>'; echo '  <id> should be an integer'; return 1;
  # else 
  #   id=$(printf "%04d" $id)
  # fi

  editor=$(git var GIT_EDITOR) || return 1

  #mkdir -p "$(dirname "$file")"
  [ -f "$path" ] || { echo "Issue $id not found"; return 1; }

  #${EDITOR:-vi} "$file"
  sh -c "$editor \"$path\"" || { echo "editor failed"; return 1; }

  # if cmp -s "$file" "$root/.issues/TEMPLATE.md"; then
  #   echo "No changes made to issue $file"
  #   read -p "Do you want to keep the file? (Y/n): " ans
  #   if [[ $ans == [Nn]* ]]; then
  #     rm -f "$file"
  #     echo "Deleted template issue file $file"
  #   else
  #     echo "Keeping template issue file $file"
  #   fi
  # else  
  #   return 0
  # fi
}

git_issue_new() {
  root=$(git_project_root)
  # cd "$root/.issues" || return 1
  wt=$(git_issue_worktree)
  if ! safe_cd "$wt"; then
    return 1
  fi

  # Initialize variables with defaults
  TITLE=""
  BODY=""
  TYPE=""
  STATUS=""
  PRIORITY=""

  # Loop through all arguments
  for i in "$@"; do
    case $i in
      --title=*)
        # Use parameter expansion to strip "--title=" from the front
        TITLE="${i#*=}"
        shift # move past the argument
        ;;
      --body=*)
        BODY="${i#*=}"
        shift
        ;;
      --type=*)
        TYPE="${i#*=}"
        shift # move past the argument
        ;;
      --status=*)
        STATUS="${i#*=}"
        shift # move past the argument
        ;;
      --priority=*)
        PRIORITY="${i#*=}"
        shift # move past the argument
        ;;
      *)
        # Handle unknown options or positional arguments
        # echo "Unknown option: $i"
        ;;
    esac
  done

  fn_md=$(new_filename ".md") || { echo "failed to generate new filename"; return 1; }

  root=$(git_project_root)
  path="$wt/issues/$fn_md"

  mkdir -p "$(dirname "$path")"
  # Validation (Optional)
  if [[ -z "$TITLE" ]]; then
   [ -f "$path" ] || cp "$wt/TEMPLATE.md" "$path"
    id=$(basename "$fn_md" .md)
    git_issue_edit "$id" || { return 1; }
    cd - || return 1
  else
    {
      echo "---"
      echo "title: $TITLE"
      [ -n "$TYPE" ] && echo "type: $TYPE"
      [ -n "$STATUS" ] && echo "status: $STATUS"
      [ -n "$PRIORITY" ] && echo "priority: $PRIORITY"
      echo "---"
      echo ""
      echo "$BODY"
    } > "$path"
    echo "Created new issue: issues/$fn_md"
    cd - || return 1
  fi  

}


git_issue_commit() {
  root=$(git_project_root)

  local wt
  wt=$(git_issue_worktree)
  if ! safe_cd "$wt"; then
      return 1
  fi

  #if git diff --cached --quiet && git diff --quiet; then
  #  echo "No issue changes to commit"
  #  return 0
  #fi

  if [ -f .git/MERGE_HEAD ]; then
    echo "merge in progress; use git issue merge --continue"; return 1
  fi

  git add issues

  #if [ -n "$1" ]; then
  #  git commit -m "$*"
  #else
  #  git commit
  #fi

  git commit "$@"
  [ $? -ne 0 ] && { echo "issue commit failed"; git restore --staged issues/; cd -; return 1; }

  git update-ref refs/issues/latest HEAD
  cd - || return 1
}


git_issue_log() {
  root="$(git_project_root)"
  remote_tracking=$(git config --get issue.remote)
  [ -z "$remote_tracking" ] && remote_tracking=$(resolve_issue_remote)
  git -C "$root/.issues" log --oneline --graph $@ --decorate-refs=HEAD --decorate-refs=refs/issues/latest --decorate-refs=remotes/"$remote_tracking/issues"
}

# git_issue_list() {
#   root=$(git_project_root)
  
#   [ ! -d "$root/.issues" ] && echo ".issue not found. Use \`git issue init\` to make one" && return 1
#   ls "$root/.issues/issues" | sed 's/\.md$//'
# }

git_issue_show() {
  id="$(parse_issue_id "$1")" || return 1
  [ -z "$id" ] && echo "usage: git issue show <id>" && return 1
  
  #if ! is_int "$id"; then echo 'usage: git issue show <id>'; echo '  <id> should be an integer'; return 1;
  #else 
    #id=$(printf "%04d" $id)
    root=$(git_project_root)
    file="$root/.issues/issues/$id.md"

    [ -f "$file" ] || { echo "Issue $id not found"; return 1; }

    echo "ISSUE-FILE: issues/$id.md"
    sed -n '1,200p' "$file"
  #fi
}

git_issue_list() {
    root=$(git_project_root)
    issues_dir="$root/.issues/issues" || return 1
  
    # check the folder .issues/
    [ ! -d "$root/.issues" ] && echo ".issue not found. Use \`git issue init\` to create new one and \`git issue clone\` to clone the remote issues" && return 1

    printf "%-13s %-8s %-8s %-8s %s\n" "ID" "STATUS" "TYPE" "PRI" "TITLE"

    while IFS= read -r -d '' f; do
        [ -f "$f" ] || continue
        id=$(basename "$f" .md)

        awk -v id="$id" '
            BEGIN {
                in_yaml = 0
                title = type = pri = status = ""
            }

            /^---$/ {
                in_yaml = !in_yaml
                next
            }

            in_yaml {
                if ($1 == "title:") {
                    sub(/^title:[[:space:]]*/, "")
                    title = $0
                }
                else if ($1 == "type:") type = substr($2, 1, 8)
                else if ($1 == "priority:") pri = substr($2, 1, 8)
                else if ($1 == "status:") status = substr($2, 1, 8)
            }

            END {
                printf "%-13s %-8s %-8s %-8s %s\n",
                       id,
                       status ? status : "-",
                       type   ? type   : "-",
                       pri    ? pri    : "-",
                       title  ? title  : "-"
            }
        ' "$f"
    done < <(find "$issues_dir" -maxdepth 1 -name "*.md" -type f -printf '%T@ %p\0' | sort -zrn | cut -zd' ' -f2-)
    

}


upper() {
    printf "%s" "$1" | tr '[:lower:]' '[:upper:]'
}

truncate() {
    max=$1
    shift
    s="$*"
    [ "${#s}" -le "$max" ] && printf "%s" "$s" ||
        printf "%s…" "${s:0:max}"
}

rel_time() {
    delta=$1  # seconds
    
    if [ "$delta" -lt 3600 ]; then
        printf -- "<   %2dM" $((delta / 60 + 1))
    elif [ "$delta" -lt 86400 ]; then
        printf -- "<   %2dH" $((delta / 3600 + 1))
    elif [ "$delta" -lt 2592000 ]; then
        printf -- "<  %2dd " $((delta / 86400 + 1))
    elif [ "$delta" -lt 31536000 ]; then
        printf -- "< %2dm  " $((delta / 2592000 + 1))
    else
        printf -- "< %2dy  " $((delta / 31536000 + 1))
    fi
}

priority_char() {
    case "$1" in
    "P1") PRI_MAP="1 " ;;
    "P2") PRI_MAP=" 2 " ;;
    "P3") PRI_MAP="  3" ;;
    *)    PRI_MAP="  ?" ;; # Default for unknown values
    esac
    
    echo "$PRI_MAP"
}

git_issue_list_full() {
    root=$(git_project_root)
    issues_rootdir="$root/.issues" || return 1
    issues_dir="$root/.issues/issues" || return 1
    wt=$(git_issue_worktree)
    if ! safe_cd "$wt"; then
      return 1
    fi # This is safter and the following cd
    # safe_cd "$issues_rootdir" || return 1
    
    #                 TYPE PRI  TITLE CHANGED
    printf "%-11s %-2s %-4s %-3s %-40s %-7s %-35s %s\n" \
        "ID" "ST" "TYPE" "PRI" "TITLE" "CHANGED" "COMMIT" "CMT_TIME"

    for f in "$issues_dir"/*.md; do
        [ -f "$f" ] || continue

        id=$(basename "$f" .md)
        rel="issues/$id.md"

        # -------- frontmatter --------
        # Read into variables without eval to avoid command injection
        while IFS= read -r line; do
            case "$line" in
                status:*)   status="${line#status:}" ; status="${status#"${status%%[![:space:]]*}"}" ;;
                type:*)     type="${line#type:}" ; type="${type#"${type%%[![:space:]]*}"}" ;;
                priority:*) pri="${line#priority:}" ; pri="${pri#"${pri%%[![:space:]]*}"}" ;;
                title:*)    title="${line#title:}" ; title="${title#"${title%%[![:space:]]*}"}" ;;
            esac
        done < <(awk '
            BEGIN { in_yaml = 0 }
            /^---$/ { in_yaml = !in_yaml; next }
            in_yaml && /^(status|type|priority|title):/ { print }
        ' "$f")

        ST=$(upper "${status:-??}"); ST=${ST:0:2}
        TYPE=$(upper "${type:-????}"); TYPE=${TYPE:0:4}
        PRI=$(upper "${pri:-???}"); PRI=${PRI:0:3}
        TITLE=$(truncate 39 "${title:-}")
        
        PRI_MAP=$(priority_char "$PRI")

        # -------- dirty / changed --------
        if git status --porcelain -- "$rel" | grep -q .; then
            now=$(date +%s)
            mtime=$(stat -c %Y "$f" 2>/dev/null || stat -f %m "$f")
            delta=$((now - mtime))
            CHANGED=$(rel_time "$delta") 
        else
            CHANGED=""
        fi

        # -------- last commit --------
        read -r cdate ctime cmsg <<EOF
$(git log -1 --pretty=format:'%cd %s' --date=format:'%Y-%m-%d %H:%M' -- "$rel" 2>/dev/null)
EOF
        
        COMMIT=$(truncate 34 "$cmsg")
        CMT_TIME=${cdate%:*}

        printf "%-11s %-2s %-4s %-3s %-40s %-7s %-35s %s\n" \
            "$id" "$ST" "$TYPE" "$PRI_MAP" "$TITLE" "$CHANGED" "$COMMIT" "$CMT_TIME"
    done | sort
    echo '==============================='
    echo '* '"CHANGED: relative time since last modification(uncommitted changes)"
    cd - > /dev/null || return 1
}

#git_issue_list_full


git_issue_search() {
  local pat=
  local title_pat=
  local body_pat=
  local ignore_case=0
  
  root=$(git_project_root)
  issues_rootdir="$root/.issues" || return 1
  issues_dir="$root/.issues/issues" || return 1

  # parse args
  for arg in "$@"; do
    case $arg in
      --title=*) title_pat=${arg#*=} ;;
      --body=*)  body_pat=${arg#*=} ;;
      -i)        ignore_case=1 ;;
      *)
        pat=$arg
        ;;
    esac
  done

  awk -v pat="$pat" \
      -v title_pat="$title_pat" \
      -v body_pat="$body_pat" \
      -v icase="$ignore_case" '

  function finish_file() {
    match_file = 1

    # field-specific predicates
    if (title_pat != "" && !(("title" in yaml) && yaml["title"] ~ title_pat))
      match_file = 0

    if (body_pat != "" && body !~ body_pat)
      match_file = 0

    # global pattern: yaml dump + body
    if (pat != "") {
      dump = body
      for (k in yaml)
        dump = dump yaml[k] "\n"
      if (dump !~ pat)
        match_file = 0
    }
    #if (match_file && FILENAME != "") print FILENAME
    if (match_file && prev_filename != "") print prev_filename 
  }  

  BEGIN {
    if (icase) IGNORECASE = 1
  }

  FNR ==1 && NR > 1 {
    finish_file()
  }

  # reset per-file state
  FNR == 1 {
    in_yaml = 0
    body = ""
    delete yaml
    prev_filename = FILENAME
  }

  # detect YAML start
  FNR == 1 && $0 == "---" {
    in_yaml = 1
    next
  }

  # detect YAML end
  in_yaml && $0 == "---" {
    in_yaml = 0
    next
  }

  # parse YAML key: value (flat only)
  in_yaml {
    if (match($0, /^[a-zA-Z0-9_-]+:[[:space:]]*/)) {
      key = substr($0, 1, index($0, ":") - 1)
      val = substr($0, index($0, ":") + 1)
      sub(/^[[:space:]]+/, "", val)
      yaml[key] = val
      #print FILENAME
      #print $0
      #print key
      #print val
    }
    next
  }

  # collect body
  {
    body = body $0 "\n"
  }

  END {
    finish_file()
  }
  ' "$issues_dir"/*.md
}



#git_issue_search Hi




resolve_issue_remote() {
  # 1. explicit CLI remote already handled by caller

  # 2. issue.remote
  local r
  r=$(git config --get issue.remote)
  [ -n "$r" ] && { echo "$r"; return; }

  # 3. remote.pushDefault
  r=$(git config --get remote.pushDefault)
  [ -n "$r" ] && { echo "$r"; return; }

  # 4. branch upstream (only if on branch)
  local branch
  branch=$(git symbolic-ref --quiet --short HEAD 2>/dev/null)
  if [ -n "$branch" ]; then
    r=$(git config --get branch.$branch.remote)
    [ -n "$r" ] && { echo "$r"; return; }
  fi

  # 5. fallback
  echo origin
}

# git_issue_remote() {
#   git config issue.remote 2>/dev/null ||
#   git config --get remote.pushDefault ||
#   echo origin
# }



git_issue_track() {
  #[ $# -eq 1 ] || { echo "usage: git issue track <remote>"; return 1; }
  if [ "$#" -gt  1 ]; then
    echo "usage: git issue track (<remote>|--unset)"
    return 1
  fi

  if [ "$#" -lt 1 ]; then
    #echo "usage: git issue track <remote>"

    # from function resolve_issue_remote
    local r
    r=$(git config --get issue.remote)
    [ -n "$r" ] && { echo "Currently tracking $r"; return; }
    
    echo "Tracking remote is not set."

        # 3. remote.pushDefault
    r=$(git config --get remote.pushDefault)
    [ -n "$r" ] && { echo "- remote.pushDefault set to $r"; return; }

    # 4. branch upstream (only if on branch)
    local branch
    branch=$(git symbolic-ref --quiet --short HEAD 2>/dev/null)
    if [ -n "$branch" ]; then
      r=$(git config --get branch.$branch.remote)
      [ -n "$r" ] && { echo "- branch.CURRENT_BRANCH($branch).remote set to $r"; return; }
    fi

    # 5. fallback
    echo "- remote would be origin if not specified"

    return 1
  fi
  
  if [ "$#" -eq 1 ]; then
    local remote=$1

    if [ "$remote" = "--unset" ]; then
      git config --unset issue.remote \
      || { echo "failed to unset issue.remote"; return 1; }
    fi

    # check remote exists
    if ! git ls-remote --exit-code "$remote" >/dev/null 2>&1; then
      echo "remote '$remote' not found"
      return 1
    fi

    git config issue.remote "$remote" \
      || { echo "failed to set issue.remote"; return 1; }

    echo "Issues now track remote '$remote'"
  fi
}





# Original
# git_issue_push() {
#   local remote=
#   local opts=()

#   remote=$(git config --get remote.pushDefault || echo origin)

#   for arg in "$@"; do
#     case "$arg" in
#       --force|-f)
#         echo "force-push is forbidden for issues"
#         return 1
#         ;;
#       -*)
#         opts+=("$arg")
#         ;;
#       *)
#         remote="$arg"
#         ;;
#     esac
#   done

#   git push "${opts[@]}" "$remote" \
#     refs/issues/latest:refs/issues/latest
# }

git_issue_push() {
  local set_upstream=0
  local force=0
  local remote=

  while [ $# -gt 0 ]; do
    case "$1" in
      -u) set_upstream=1 ;;
      #--force|-f) force=1 ;;
      *) remote=$1 ;;
    esac
    shift
  done

  if [ $set_upstream -eq 1 ] && [ -z "$remote" ]; then
    echo "remote must be specified when using -u"
    return 1
  fi

  remote=${remote:-$(resolve_issue_remote)}
  url_remote="$(git remote get-url --push "$remote")"

  if [[ ! ( "$url_remote" =~ ^file:// || \
            "$url_remote" =~ ^ssh:// || \
            "$url_remote" =~ ^git:// ||
            "$url_remote" =~ ^https:// ||
            "$url_remote" =~ ^http:// ) ]]; then

    if ! is_git_scp_like_host_path "$url_remote"; then # not scp-like
      if [[ ! "$url_remote" = /* ]]; then # not absolute path
        local root 
        root="$(git_project_root)"
        echo '!W: Relative local paths would not work for worktree.'
        echo '    If it failes, try delete and create '"$remote"' again using the following:'
        echo '    - git remote remove '"$remote"
        echo '    - git remote add '"$remote"' '"$(realpath "$root"/"$url_remote")"
        echo '    - git issue push '"$remote"
      else
        echo '!W: Your remote may be ambiguous whether it is scp or local path'
        echo '    If it failes, try ssh:// or file://'"$url_remote"
      fi
    fi
  fi
  echo 'Pushing issues to remote '"$remote"'...'

  local L R
  L=$(issue_ref)
  R=$(remote_issue_ref "$remote")

# ! replace die
#   replace die "([^"]+)"
#   with { echo "$1"; return 1; }

  # ensure local ref exists
  git show-ref --verify --quiet "$L" \
    || { echo "no local issue snapshot ($L)"; return 1; }

  # fetch remote state for safety check
  # git_issue_fetch "$remote"
  #commnted: isolate fetch from push

  if [ $force -eq 0 ] && git show-ref --verify --quiet "$R"; then
    git merge-base --is-ancestor "$R" "$L" \
      || { echo "remote issues have advanced; do "git issue fetch" first"; return 1; }
  fi

  if git push "$remote" "$L:$L"; then
    echo -n "push successful"
    if git_issue_fetch; then
      echo "; local snapshot updated"
    else
      echo "; but failed to update local snapshot"
    fi
  else
    echo "push failed"; return 1; 
  fi


  if [ $set_upstream -eq 1 ]; then
    git config issue.remote "$remote"
    echo "Tracking remote set to '$remote'"
  fi
}


git_issue_fetch() {
  local remote=
  local opts=()

  for arg in "$@"; do
    case "$arg" in
      -*)
        opts+=("$arg")
        ;;
      *)
        remote="$arg"
        ;;
    esac
  done

  remote=${remote:-$(resolve_issue_remote)}

  git fetch "${opts[@]}" "$remote" \
    "$(issue_ref):$(remote_issue_ref "$remote")" \
    || { echo "fetch failed"; return 1; }
}


# clone-issue workflow:
# 1. git issue fetch
# 2. git worktree add .issues/ origin/issues/latest
# 3. git issue list



issue_merge_in_progress() {
  issue_git rev-parse -q --verify MERGE_HEAD >/dev/null 2>&1
}

git_issue_merge() {
  local mode=
  local remote=
  local opts=()

  for arg in "$@"; do
    case "$arg" in
      --abort)
        if [ "$mode" = "--continue" ]; then
          echo "cannot use --abort and --continue together"
          return 1
        fi
        mode="--abort"
        ;;
      --continue)
        mode="--continue"
        if [ "$mode" = "--abort" ]; then
          echo "cannot use --abort and --continue together"
          return 1
        fi
        mode="--continue"
        ;;
      -*)
        opts+=("$arg")
        ;;
      *)
        remote="$arg"
        ;;
    esac
  done

  #remote=$(git_issue_remote)
  remote=${remote:-$(resolve_issue_remote)}

  local wt
  wt=$(git_issue_worktree)

  local local_ref remote_ref
  local_ref=$(issue_ref)
  remote_ref=$(remote_issue_ref "$remote")

  issue_git show-ref --verify --quiet "$local_ref" \
    || { echo "no local issue snapshot"; return 1; }

  issue_git show-ref --verify --quiet "$remote_ref" \
    || { echo "no remote issue snapshot for '$remote'"; return 1; }

  (
    cd "$wt" || { echo "failed to enter issue worktree $wt"; return 1; }

    case $mode in
      --abort)
        git rebase --abort 2>/dev/null || git merge --abort
        return 0
        ;;
      --continue)
        if [ -f .git/MERGE_HEAD ]; then
          git commit || die "commit failed"
          git update-ref "$local_ref" HEAD
          return 0
        else
          die "no merge to continue"
        fi
        ;;
    esac

    #git fetch "$remote" \
    #  "refs/issues/latest:$remote_ref" || die "fetch failed"

    local local_oid remote_oid
    local_oid=$(git rev-parse "$local_ref")
    remote_oid=$(git rev-parse "$remote_ref")

    # Fast-forward?
    if git merge-base --is-ancestor "$local_oid" "$remote_oid"; then
      # git reset --hard "$remote_oid"

      new_opts=()
      local ff=1
      for opt in "${opts[@]}"; do
        #if [[ "$opt" != "--ff" && "$opt" != "--no-ff" ]]; then
        #  new_opts+=("$opt")
        if [[ "$opt" = "--ff" ]]; then
          ff=1
        elif [[ "$opt" = "--no-ff" || "$opt" = "ff-only" ]]; then
          ff=0
          new_opts+=("$opt")
        fi
      done
      opts=("${new_opts[@]}")


      if [[ $ff -eq 1 ]]; then
        git merge --ff "${opts[@]}" "$remote_oid" 
      else
        git merge "${opts[@]}" "$remote_oid"
      fi

      git update-ref "$local_ref" HEAD
      return 0
    fi

    #output=$(git rebase "$remote_oid" 2>&1)
    #if [ $? -eq 0 ]; then
    if output=$(git rebase "$remote_oid" 2>&1); then
      echo "$output"
      git update-ref "$local_ref" HEAD
      return 0
    else
      echo "rebase failed, falling back to merge..."
      git rebase --abort > /dev/null 2>&1
      if git merge "${opts[@]}" "$remote_oid"; then
        git update-ref "$local_ref" HEAD
        return 0
      fi
    fi

    # # Try rebase
    # if git rebase "$remote_oid"; then
    #   git update-ref "$local_ref" HEAD
    #   return 0
    # fi

    # # Rebase failed → fallback to merge
    # git rebase --abort

    # if git merge "${opts[@]}" "$remote_oid"; then
    #   git update-ref "$local_ref" HEAD
    #   return 0
    # fi

    echo "Conflict detected. Resolve and run:"
    echo "  git issue merge --continue"
    echo "  git issue merge --abort"
    return 1
  )
}


git_issue_status() {
  local wt
  wt=$(git_issue_worktree)

  (
    #cd "$wt" 2> /dev/null || { echo 'E: .issues not yet initiated.'; echo '  - use "git issue init" and "git issue pull"'; return 1; }
    if ! safe_cd "$wt"; then
        return 1
    fi

    issue_gitdir=$(git rev-parse --git-dir)
    if [ -f "$issue_gitdir"/MERGE_HEAD ]; then
      echo "Issue merge in progress"
      git status --short
      exit 0
    fi

    #if git diff-index --quiet HEAD -- || \
    #  [ -n "$(git ls-files --others --exclude-standard)" ]; then
    #  echo "Repository has changes or untracked files"
    #fi

    local remote_tracking
    #remote=$(git_issue_remote)
    remote_tracking=$(git config --get issue.remote)
    remote_tracking=${remote_tracking:-$(resolve_issue_remote)}
    if [ -n "$remote_tracking" ]; then
      #echo "$remote_tracking"  

      local local_oid remote_oid
      local_oid=$(git rev-parse "$(issue_ref)")
      #remote_oid=$(git rev-parse "$(remote_issue_ref "$remote_tracking")" 2>/dev/null)
      if ! remote_oid=$(git rev-parse "$(remote_issue_ref "$remote_tracking")" 2>/dev/null );  then
        echo "No remote issue snapshot for '$remote_tracking'"
        #return 1
      elif [ -n "$remote_oid" ]; then
        if [ "$local_oid" = "$remote_oid" ]; then
          echo "Issues up to date with tracking remote $remote_tracking"
        elif git merge-base --is-ancestor "$local_oid" "$remote_oid"; then
          printf "Issues behind tracking remote $remote_tracking by %s commits\n" \
            "$(git rev-list --count "$local_oid..$remote_oid")"
        elif git merge-base --is-ancestor "$remote_oid" "$local_oid"; then
          printf "Issues ahead of tracking remote $remote_tracking by %s commits\n" \
            "$( git rev-list --count "$remote_oid..$local_oid")"
        else
          printf "Issues diverged: Ahead %s, Behind %s\n" \
            "$(git rev-list --count "$remote_oid..$local_oid")" \
            "$(git rev-list --count "$local_oid..$remote_oid")"
        fi
      fi
    else
      echo "No tracking remote set for issues"
    fi

    # if git diff-index --quiet HEAD -- || \
    #   [ -n "$(git ls-files --others --exclude-standard)" ]; then
    #   echo "No changes since last commit"
    # else
      git status --short
    # fi
  )
}


