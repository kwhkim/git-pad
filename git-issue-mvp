#!/bin/bash

git_project_root() {
    git worktree list --porcelain |
    awk '$1=="worktree" { print $2; exit }'
}

is_int() {
  [[ $1 =~ ^-?[0-9]+$ ]]
}

issue_git() {
  root=$(git_project_root)
  git -C "$root/.issues" "$@"
}




git_issue_init() {
  root=$(git_project_root)

  [ -d "$root/.issues" ] && {
    echo ".issues already exists. Use the following to remove it"
    echo ""
    echo "  git worktree remove $root/.issues"
    return 0
  }
  
  echo ".issue/" >> "$root/.git/info/exclude"

#: since git worktree add --orphan is used, no more needed?
#  if git rev-parse --verify HEAD >/dev/null 2>&1; then
#    has_commit=1
#  else
#    has_commit=0
#    echo "Needs at least one commit before git issue init"
#    return 0
#  fi
  

  # Create orphan detached worktree
  # git worktree add --detach "$root/.issues" 
  # cd "$root/.issues" || return 1

  tmp_ref="refs/issues/tmp/$(date +%s)-$$"
  #git worktree add --orphan -B temp_issues $root/.issues
  git worktree add --orphan -B $tmp_ref $root/.issues
  mkdir -p $root/.issues/issues
  
  git config --local extensions.worktreeConfig
  cd $root/.issues  
  git config --worktree advice.detachedHead false 
  
  cat > TEMPLATE.md <<'EOF'
---
title:
type: bug|feature|task|meta
status: open|in-progress|closed
priority: P1|P2|P3
severity: critical|high|medium|low
---

## Description

## Steps to Reproduce

## Expected Behavior

## Notes
EOF

#  cp TEMPLATE.md .issues/TEMPLATE.md

#  cat > issues/0001.md <<'EOF'
#---
#title: Initial issue tracking setup
#type: meta
#priority: low
#---
#
#Issue tracking initialized.
#EOF

  git add .
  git commit -m "issue init: templates loaded"
  commit=$(git rev-parse HEAD)
  
  #git update-ref "$ISSUE_REF_PREFIX/$issue_id" 
  git update-ref refs/issues/latest $commit

  echo "Initialized issue tracking in .issues/"
  
  git checkout --detach
  #git branch -D temp_issues
  git branch -D $tmp_ref
  cd - || { echo "failed to restore the directory"; return 1; }
}


git_issue_edit() {
  id=$1
  fn_md="$id".md
  #fn=$1
  [ -z "$fn_md" ] && { echo "usage: git issue edit <id>"; return 1; }

  # if ! is_int "$id"; then echo 'usage: git issue show <id>'; echo '  <id> should be an integer'; return 1;
  # else 
  #   id=$(printf "%04d" $id)
  # fi

  editor=$(git var GIT_EDITOR) || return 1

  root=$(git_project_root)
  wt=$(git_issue_worktree)
  path="$wt/issues/$fn_md"

  #mkdir -p "$(dirname "$file")"
  [ -f "$path" ] || { echo "Issue $id not found"; return 1; }

  #${EDITOR:-vi} "$file"
  sh -c "$editor \"$path\"" || { echo "editor failed"; return 1; }

  # if cmp -s "$file" "$root/.issues/TEMPLATE.md"; then
  #   echo "No changes made to issue $file"
  #   read -p "Do you want to keep the file? (Y/n): " ans
  #   if [[ $ans == [Nn]* ]]; then
  #     rm -f "$file"
  #     echo "Deleted template issue file $file"
  #   else
  #     echo "Keeping template issue file $file"
  #   fi
  # else  
  #   return 0
  # fi
}

git_issue_new() {
  root=$(git_project_root)
  # cd "$root/.issues" || return 1
  wt=$(git_issue_worktree)
  if ! safe_cd "$wt"; then
        return 1
  fi

  fn_md=$(new_filename ".md") || { echo "failed to generate new filename"; return 1; }

  root=$(git_project_root)
  path="$wt/issues/$fn_md"

  mkdir -p "$(dirname "$path")"
  [ -f "$path" ] || cp "$wt/TEMPLATE.md" "$path"

  id=$(basename "$fn_md" .md)
  git_issue_edit "$id" || { return 1; }
  cd - || return 1
}


git_issue_commit() {
  root=$(git_project_root)
  cd "$root/.issues" || return 1

  #if git diff --cached --quiet && git diff --quiet; then
  #  echo "No issue changes to commit"
  #  return 0
  #fi

  if [ -f .git/MERGE_HEAD ]; then
    echo "merge in progress; use git issue merge --continue"; return 1
  fi

  git add issues

  #if [ -n "$1" ]; then
  #  git commit -m "$*"
  #else
  #  git commit
  #fi

  git commit "$@"
  [ $? -ne 0 ] && { echo "issue commit failed"; git restore --staged issues/; cd -; return 1; }

  git update-ref refs/issues/latest HEAD
  cd - || return 1
}

git_issue_status() {
  root=$(git_project_root)
  output=$(git -C "$root/.issues" status --short)
  if [[ $output == "" ]]; then
    echo 'Nothing changed since the last commit'
  else 
    git -C "$root/.issues" status --short
  fi
}

git_issue_log() {
  root=$(git_project_root)
  git -C "$root/.issues" log --oneline --decorate $@
}

# git_issue_list() {
#   root=$(git_project_root)
  
#   [ ! -d "$root/.issues" ] && echo ".issue not found. Use \`git issue init\` to make one" && return 1
#   ls "$root/.issues/issues" | sed 's/\.md$//'
# }

git_issue_show() {
  id=$1
  [ -z "$id" ] && echo "usage: git issue show <id>" && return 1
  
  #if ! is_int "$id"; then echo 'usage: git issue show <id>'; echo '  <id> should be an integer'; return 1;
  #else 
    #id=$(printf "%04d" $id)
    root=$(git_project_root)
    file="$root/.issues/issues/$id.md"

    [ -f "$file" ] || { echo "Issue $id not found"; return 1; }

    echo "ISSUE-FILE: issues/$id.md"
    sed -n '1,200p' "$file"
  #fi
}

git_issue_list() {
    root=$(git_project_root)
    issues_dir="$root/.issues/issues" || return 1
  
    # check the folder .issues/
    [ ! -d "$root/.issues" ] && echo ".issue not found. Use \`git issue init\` to make one" && return 1

    printf "%-13s %-8s %-8s %-8s %s\n" "ID" "STATUS" "TYPE" "PRI" "TITLE"

    while IFS= read -r -d '' f; do
        [ -f "$f" ] || continue
        id=$(basename "$f" .md)

        awk -v id="$id" '
            BEGIN {
                in_yaml = 0
                title = type = pri = status = ""
            }

            /^---$/ {
                in_yaml = !in_yaml
                next
            }

            in_yaml {
                if ($1 == "title:") {
                    sub(/^title:[[:space:]]*/, "")
                    title = $0
                }
                else if ($1 == "type:") type = substr($2, 1, 8)
                else if ($1 == "priority:") pri = substr($2, 1, 8)
                else if ($1 == "status:") status = substr($2, 1, 8)
            }

            END {
                printf "%-13s %-8s %-8s %-8s %s\n",
                       id,
                       status ? status : "-",
                       type   ? type   : "-",
                       pri    ? pri    : "-",
                       title  ? title  : "-"
            }
        ' "$f"
    done < <(find "$issues_dir" -maxdepth 1 -name "*.md" -type f -printf '%T@ %p\0' | sort -zrn | cut -zd' ' -f2-)
    

}


upper() {
    printf "%s" "$1" | tr '[:lower:]' '[:upper:]'
}

truncate() {
    max=$1
    shift
    s="$*"
    [ "${#s}" -le "$max" ] && printf "%s" "$s" ||
        printf "%s…" "${s:0:max}"
}

rel_time() {
    delta=$1  # seconds
    
    if [ "$delta" -lt 3600 ]; then
        printf -- "<   %2dM" $((delta / 60 + 1))
    elif [ "$delta" -lt 86400 ]; then
        printf -- "<   %2dH" $((delta / 3600 + 1))
    elif [ "$delta" -lt 2592000 ]; then
        printf -- "<  %2dd " $((delta / 86400 + 1))
    elif [ "$delta" -lt 31536000 ]; then
        printf -- "< %2dm  " $((delta / 2592000 + 1))
    else
        printf -- "< %2dy  " $((delta / 31536000 + 1))
    fi
}

priority_char() {
    case "$1" in
    "P1") PRI_MAP="1 " ;;
    "P2") PRI_MAP=" 2 " ;;
    "P3") PRI_MAP="  3" ;;
    *)    PRI_MAP="  ?" ;; # Default for unknown values
    esac
    
    echo "$PRI_MAP"
}

git_issue_list_full() {
    root=$(git_project_root)
    issues_rootdir="$root/.issues" || return 1
    issues_dir="$root/.issues/issues" || return 1
    cd "$issues_rootdir" 
    
    #                 TYPE PRI  TITLE CHANGED
    printf "%-11s %-2s %-4s %-3s %-40s %-7s %-35s %s\n" \
        "ID" "ST" "TYPE" "PRI" "TITLE" "CHANGED" "COMMIT" "CMT_TIME"

    for f in "$issues_dir"/*.md; do
        [ -f "$f" ] || continue

        id=$(basename "$f" .md)
        rel="issues/$id.md"

        # -------- frontmatter --------
        # Read into variables without eval to avoid command injection
        while IFS= read -r line; do
            case "$line" in
                status:*)   status="${line#status:}" ; status="${status#"${status%%[![:space:]]*}"}" ;;
                type:*)     type="${line#type:}" ; type="${type#"${type%%[![:space:]]*}"}" ;;
                priority:*) pri="${line#priority:}" ; pri="${pri#"${pri%%[![:space:]]*}"}" ;;
                title:*)    title="${line#title:}" ; title="${title#"${title%%[![:space:]]*}"}" ;;
            esac
        done < <(awk '
            BEGIN { in_yaml = 0 }
            /^---$/ { in_yaml = !in_yaml; next }
            in_yaml && /^(status|type|priority|title):/ { print }
        ' "$f")

        ST=$(upper "${status:-??}"); ST=${ST:0:2}
        TYPE=$(upper "${type:-????}"); TYPE=${TYPE:0:4}
        PRI=$(upper "${pri:-???}"); PRI=${PRI:0:3}
        TITLE=$(truncate 39 "${title:-}")
        
        PRI_MAP=$(priority_char "$PRI")

        # -------- dirty / changed --------
        if git status --porcelain -- "$rel" | grep -q .; then
            now=$(date +%s)
            mtime=$(stat -c %Y "$f" 2>/dev/null || stat -f %m "$f")
            delta=$((now - mtime))
            CHANGED=$(rel_time "$delta") 
        else
            CHANGED=""
        fi

        # -------- last commit --------
        read -r cdate ctime cmsg <<EOF
$(git log -1 --pretty=format:'%cd %s' --date=format:'%Y-%m-%d %H:%M' -- "$rel" 2>/dev/null)
EOF
        
        COMMIT=$(truncate 34 "$cmsg")
        CMT_TIME=${cdate%:*}

        printf "%-11s %-2s %-4s %-3s %-40s %-7s %-35s %s\n" \
            "$id" "$ST" "$TYPE" "$PRI_MAP" "$TITLE" "$CHANGED" "$COMMIT" "$CMT_TIME"
    done | sort
    echo '==============================='
    echo '* '"CHANGED: relative time since last modification(uncommitted changes)"
    cd - > /dev/null
}

#git_issue_list_full


git_issue_search() {
  local pat=
  local title_pat=
  local body_pat=
  local ignore_case=0
  
  root=$(git_project_root)
  issues_rootdir="$root/.issues" || return 1
  issues_dir="$root/.issues/issues" || return 1

  # parse args
  for arg in "$@"; do
    case $arg in
      --title=*) title_pat=${arg#*=} ;;
      --body=*)  body_pat=${arg#*=} ;;
      -i)        ignore_case=1 ;;
      *)
        pat=$arg
        ;;
    esac
  done

  awk -v pat="$pat" \
      -v title_pat="$title_pat" \
      -v body_pat="$body_pat" \
      -v icase="$ignore_case" '

  function finish_file() {
    match_file = 1

    # field-specific predicates
    if (title_pat != "" && !(("title" in yaml) && yaml["title"] ~ title_pat))
      match_file = 0

    if (body_pat != "" && body !~ body_pat)
      match_file = 0

    # global pattern: yaml dump + body
    if (pat != "") {
      dump = body
      for (k in yaml)
        dump = dump yaml[k] "\n"
      if (dump !~ pat)
        match_file = 0
    }
    #if (match_file && FILENAME != "") print FILENAME
    if (match_file && prev_filename != "") print prev_filename 
  }  

  BEGIN {
    if (icase) IGNORECASE = 1
  }

  FNR ==1 && NR > 1 {
    finish_file()
  }

  # reset per-file state
  FNR == 1 {
    in_yaml = 0
    body = ""
    delete yaml
    prev_filename = FILENAME
  }

  # detect YAML start
  FNR == 1 && $0 == "---" {
    in_yaml = 1
    next
  }

  # detect YAML end
  in_yaml && $0 == "---" {
    in_yaml = 0
    next
  }

  # parse YAML key: value (flat only)
  in_yaml {
    if (match($0, /^[a-zA-Z0-9_-]+:[[:space:]]*/)) {
      key = substr($0, 1, index($0, ":") - 1)
      val = substr($0, index($0, ":") + 1)
      sub(/^[[:space:]]+/, "", val)
      yaml[key] = val
      #print FILENAME
      #print $0
      #print key
      #print val
    }
    next
  }

  # collect body
  {
    body = body $0 "\n"
  }

  END {
    finish_file()
  }
  ' "$issues_dir"/*.md
}



#git_issue_search Hi


issue_ref() {
  echo "refs/issues/latest"
}

remote_issue_ref() {
  local remote=$1
  echo "refs/remotes/$remote/issues/latest"
}

git_issue_worktree() {
  root=$(git_project_root)
  issues_rootdir="$root/.issues" || { echo ""; return 1; }
  echo "$issues_rootdir"
}


resolve_issue_remote() {
  # 1. explicit CLI remote already handled by caller

  # 2. issue.remote
  local r
  r=$(git config --get issue.remote)
  [ -n "$r" ] && { echo "$r"; return; }

  # 3. remote.pushDefault
  r=$(git config --get remote.pushDefault)
  [ -n "$r" ] && { echo "$r"; return; }

  # 4. branch upstream (only if on branch)
  local branch
  branch=$(git symbolic-ref --quiet --short HEAD 2>/dev/null)
  if [ -n "$branch" ]; then
    r=$(git config --get branch.$branch.remote)
    [ -n "$r" ] && { echo "$r"; return; }
  fi

  # 5. fallback
  echo origin
}

# git_issue_remote() {
#   git config issue.remote 2>/dev/null ||
#   git config --get remote.pushDefault ||
#   echo origin
# }



git_issue_track() {
  #[ $# -eq 1 ] || { echo "usage: git issue track <remote>"; return 1; }
  if [ "$#" -gt  1 ]; then
    echo "usage: git issue track (<remote>|--unset)"
    return 1
  fi

  if [ "$#" -lt 1 ]; then
    #echo "usage: git issue track <remote>"

    # from function resolve_issue_remote
    local r
    r=$(git config --get issue.remote)
    [ -n "$r" ] && { echo "Currently tracking $r"; return; }
    
    echo "Tracking remote is not set."

        # 3. remote.pushDefault
    r=$(git config --get remote.pushDefault)
    [ -n "$r" ] && { echo "- remote.pushDefault set to $r"; return; }

    # 4. branch upstream (only if on branch)
    local branch
    branch=$(git symbolic-ref --quiet --short HEAD 2>/dev/null)
    if [ -n "$branch" ]; then
      r=$(git config --get branch.$branch.remote)
      [ -n "$r" ] && { echo "- branch.CURRENT_BRANCH($branch).remote set to $r"; return; }
    fi

    # 5. fallback
    echo "- remote would be origin if not specified"

    return 1
  fi
  
  if [ "$#" -eq 1 ]; then
    local remote=$1

    if [ "$remote" = "--unset" ]; then
      git config --unset issue.remote \
      || { echo "failed to unset issue.remote"; return 1; }
    fi

    # check remote exists
    if ! git ls-remote --exit-code "$remote" >/dev/null 2>&1; then
      echo "remote '$remote' not found"
      return 1
    fi

    git config issue.remote "$remote" \
      || { echo "failed to set issue.remote"; return 1; }

    echo "Issues now track remote '$remote'"
  fi
}





# Original
git_issue_push() {
  local remote=
  local opts=()

  remote=$(git config --get remote.pushDefault || echo origin)

  for arg in "$@"; do
    case "$arg" in
      --force|-f)
        echo "force-push is forbidden for issues"
        return 1
        ;;
      -*)
        opts+=("$arg")
        ;;
      *)
        remote="$arg"
        ;;
    esac
  done

  git push "${opts[@]}" "$remote" \
    refs/issues/latest:refs/issues/latest
}

git_issue_push() {
  local set_upstream=0
  local force=0
  local remote=

  while [ $# -gt 0 ]; do
    case "$1" in
      -u) set_upstream=1 ;;
      --force|-f) force=1 ;;
      *) remote=$1 ;;
    esac
    shift
  done

  remote=${remote:-$(resolve_issue_remote)}
  echo 'Pushing issues to remote '"$remote"'...'

  local L R
  L=$(issue_ref)
  R=$(remote_issue_ref "$remote")

# ! replace die
#   replace die "([^"]+)"
#   with { echo "$1"; return 1; }

  # ensure local ref exists
  git show-ref --verify --quiet "$L" \
    || { echo "no local issue snapshot ($L)"; return 1; }

  # fetch remote state for safety check
  git_issue_fetch "$remote"

  if [ $force -eq 0 ] && git show-ref --verify --quiet "$R"; then
    git merge-base --is-ancestor "$R" "$L" \
      || { echo "remote issues have advanced; use --force"; return 1; }
  fi

  git push "$remote" "$L:$L" \
    || { echo "push failed"; return 1; }

  if [ $set_upstream -eq 1 ]; then
    git config issue.remote "$remote"
    echo "Tracking remote set to '$remote'"
  fi
}


git_issue_fetch() {
  local remote=
  local opts=()

  for arg in "$@"; do
    case "$arg" in
      -*)
        opts+=("$arg")
        ;;
      *)
        remote="$arg"
        ;;
    esac
  done

  remote=${remote:-$(resolve_issue_remote)}

  git fetch "${opts[@]}" "$remote" \
    "$(issue_ref):$(remote_issue_ref "$remote")" \
    || { echo "fetch failed"; return 1; }
}


# clone-issue workflow:
# 1. git issue fetch
# 2. git worktree add .issues/ origin/issues/latest
# 3. git issue list



issue_merge_in_progress() {
  issue_git rev-parse -q --verify MERGE_HEAD >/dev/null 2>&1
}

git_issue_merge() {
  local mode=
  local remote=
  local opts=()

  for arg in "$@"; do
    case "$arg" in
      --abort)
        if [ "$mode" = "--continue" ]; then
          echo "cannot use --abort and --continue together"
          return 1
        fi
        mode="--abort"
        ;;
      --continue)
        mode="--continue"
        if [ "$mode" = "--abort" ]; then
          echo "cannot use --abort and --continue together"
          return 1
        fi
        mode="--continue"
        ;;
      -*)
        opts+=("$arg")
        ;;
      *)
        remote="$arg"
        ;;
    esac
  done

  #remote=$(git_issue_remote)
  remote=${remote:-$(resolve_issue_remote)}

  local wt
  wt=$(git_issue_worktree)

  local local_ref remote_ref
  local_ref=$(issue_ref)
  remote_ref=$(remote_issue_ref "$remote")

  issue_git show-ref --verify --quiet "$local_ref" \
    || { echo "no local issue snapshot"; return 1; }

  issue_git show-ref --verify --quiet "$remote_ref" \
    || { echo "no remote issue snapshot for '$remote'"; return 1; }

  (
    cd "$wt" || { echo "failed to enter issue worktree $wt"; return 1; }

    case $mode in
      --abort)
        git rebase --abort 2>/dev/null || git merge --abort
        return 0
        ;;
      --continue)
        if [ -f .git/MERGE_HEAD ]; then
          git commit || die "commit failed"
          git update-ref "$local_ref" HEAD
          return 0
        else
          die "no merge to continue"
        fi
        ;;
    esac

    #git fetch "$remote" \
    #  "refs/issues/latest:$remote_ref" || die "fetch failed"

    local local_oid remote_oid
    local_oid=$(git rev-parse "$local_ref")
    remote_oid=$(git rev-parse "$remote_ref")

    # Fast-forward?
    if git merge-base --is-ancestor "$local_oid" "$remote_oid"; then
      # git reset --hard "$remote_oid"
      git merge "${opts[@]}" "$remote_oid"
      git update-ref "$local_ref" HEAD
      return 0
    fi

    #output=$(git rebase "$remote_oid" 2>&1)
    #if [ $? -eq 0 ]; then
    if output=$(git rebase "$remote_oid" 2>&1); then
      echo "$output"
      git update-ref "$local_ref" HEAD
      return 0
    else
      echo "rebase failed, falling back to merge..."
      git rebase --abort > /dev/null 2>&1
      if git merge "${opts[@]}" "$remote_oid"; then
        git update-ref "$local_ref" HEAD
        return 0
      fi
    fi

    # # Try rebase
    # if git rebase "$remote_oid"; then
    #   git update-ref "$local_ref" HEAD
    #   return 0
    # fi

    # # Rebase failed → fallback to merge
    # git rebase --abort

    # if git merge "${opts[@]}" "$remote_oid"; then
    #   git update-ref "$local_ref" HEAD
    #   return 0
    # fi

    echo "Conflict detected. Resolve and run:"
    echo "  git issue merge --continue"
    echo "  git issue merge --abort"
    return 1
  )
}

safe_cd() {
    local path="$1"
    if [ ! -e "$path" ]; then
        echo "Issue worktree not yet initiated(.issues does not exist)" >&2
        echo "  - use 'git issue init' to create one" >&2
        return 1
    elif [ ! -d "$path" ]; then
        echo "Error: .issues is not a directory" >&2
        return 1
    elif [ ! -x "$path" ]; then
        echo "Error: Permission denied (no execute permission): $path" >&2
        return 1
    elif ! cd "$path" 2>&1; then
        echo "Error: Cannot cd to $path (unknown reason)" >&2
        return 1
    fi
    return 0
}

git_issue_status() {
  local wt
  wt=$(git_issue_worktree)

  (
    #cd "$wt" 2> /dev/null || { echo 'E: .issues not yet initiated.'; echo '  - use "git issue init" and "git issue pull"'; return 1; }
    if ! safe_cd "$wt"; then
        return 1
    fi

    issue_gitdir=$(git rev-parse --git-dir)
    if [ -f "$issue_gitdir"/MERGE_HEAD ]; then
      echo "Issue merge in progress"
      git status --short
      exit 0
    fi

    local remote_tracking
    #remote=$(git_issue_remote)
    remote_tracking=$(git config --get issue.remote)
    if [ -n "$remote_tracking" ]; then
      #echo "$remote_tracking"  

      local local_oid remote_oid
      local_oid=$(git rev-parse "$(issue_ref)")
      #remote_oid=$(git rev-parse "$(remote_issue_ref "$remote_tracking")" 2>/dev/null)
      if ! remote_oid=$(git rev-parse "$(remote_issue_ref "$remote_tracking")" 2>/dev/null );  then
        echo "No remote issue snapshot for '$remote_tracking'"
        #return 1
      elif [ -n "$remote_oid" ]; then
        if [ "$local_oid" = "$remote_oid" ]; then
          echo "Issues up to date with remote $remote_tracking"
        elif git merge-base --is-ancestor "$local_oid" "$remote_oid"; then
          printf "Issues behind remote $remote_tracking by %s commits\n" \
            "$(git rev-list --count "$local_oid..$remote_oid")"
        elif git merge-base --is-ancestor "$remote_oid" "$local_oid"; then
          printf "Issues ahead of remote $remote_tracking by %s commits\n" \
            "$( git rev-list --count "$remote_oid..$local_oid")"
        else
          printf "Issues diverged: Ahead %s, Behind %s\n" \
            "$(git rev-list --count "$remote_oid..$local_oid")" \
            "$(git rev-list --count "$local_oid..$remote_oid")"
        fi
      fi
    fi

    git status --short
  )
}


