#!/bin/bash

print_hline() {
  local cols
  cols=$(tput cols 2>/dev/null || echo 80)
  printf '%*s\n' "$cols" '' | tr ' ' '='
}

is_int() {
  [[ $1 =~ ^-?[0-9]+$ ]]
}

# Remote Protocol
# file://
# path starting with / or not, ending with .git
# git://
# https://
# ssh://
# [user@]server: [^/]+@[^/]+: as an SSH URL
# Git's disambiguation rules
# 1. If the string contains a / before the :, it is never scp-like.
# 2. On Windows, C:\, D:repo are never scp-like.
# 3. For host:path, Git checks:
#   host has no slashes
#   host contains only hostname-legal characters
#   path is not empty
#
is_git_scp_like_host_path() {
  local url="$1"
  local host path host_part

  # must contain exactly one colon (first colon matters)
  case "$url" in
    *:*) ;;
    *) return 1 ;;
  esac

  host_part="${url%%:*}"
  path="${url#*:}"

  # path must not be empty to be scp-like
  [ -n "$path" ] || return 1

  # reject if '/' appears before the colon
  case "$host_part" in
    */*) return 1 ;;
  esac

  # strip optional user@ (take part after last @)
  host="${host_part##*@}"

  # host must be non-empty
  [ -n "$host" ] || return 1

  # hostname-legal characters: [A-Za-z0-9.-]+
  # Use case statement for character validation instead of regex
  # First check if it contains any invalid characters
  case "$host" in
    *[!A-Za-z0-9.-]*) return 1 ;;  # Contains invalid chars
    "") return 1 ;;                 # Empty string
  esac

  # Windows drive-letter exclusion (only if running on Windows Git)
  # Safe to keep on Unix — it never triggers
  case "${OSTYPE:-}" in
    msys*|cygwin*)
      # Check if host is a single letter (Windows drive)
      case "$host" in
        [A-Za-z]) return 1 ;;
      esac
      ;;
  esac

  return 0 # scp-like
}

safe_cd() {
  local path="$1"
  if [ ! -e "$path" ]; then
    echo '!E: '"directory $path does not exist" >&2
    return 1
  elif [ ! -d "$path" ]; then
    echo '!E: '"$path is not a directory" >&2
    return 1
  elif [ ! -x "$path" ]; then
    echo '!E: '"Permission denied (no execute permission): $path" >&2
    return 1
  elif ! cd "$path" 2>&1; then
    echo '!E: '"Cannot cd to $path (unknown reason)" >&2
    return 1
  fi
  return 0
}

git_project_root() {
  git worktree list --porcelain |
    awk '$1=="worktree" { print $2; exit }'
  # You can use
  #   dirname "$(git rev-parse --git-common-dir)"
  # Testing
  #   if [ "$(git_project_root)" != "$(realpath $(dirname $(git rev-parse --git-common-dir)))" ]; then echo "alarm!"; fi
  # git rev-parse --git-common-dir return . in the root directory
}

#GIT_ISSUE_DIR=".issues"
git_issue_worktree() {
  # shellcheck disable=SC2155
  local root="$(git_project_root)"
  issues_rootdir="$root/.issues" || {
    echo ""
    return 1
  }
  echo "$issues_rootdir"
}

issue_ref() {
  echo "refs/issues/latest"
}

issue_audit_ref() {
  local local_id
  local_id="$(cat "$(git_issue_worktree)/.local-repo-id" 2> /dev/null || echo "local")"
  echo "refs/issues/audit/$local_id"
}

remote_issue_ref() {
  local remote="$1"
  echo "refs/remotes/$remote/issues/latest"
}

issue_git() {
  #root="$(git_project_root)"
  wt="$(git_issue_worktree)"
  #git -C "$root/.issues" "$@"
  git -C "$wt" "$@"
}

git_issue_clone() {
  root="$(git_project_root)"
  #remote=$(git_issue_remote)
  local wt
  wt=$(git_issue_worktree)

  cd "$root" > /dev/null || return 1

  if [ $# -eq 1 ]; then 
    remote="$1"
  elif [ $# -gt 1 ]; then
    echo '!E: Usage git issue clone <remote>'
    return 1
  fi

  if ! remote=${remote:-$(resolve_issue_remote)}; then
    echo '!E: No remote, no default'
    echo '- Uage: git issue clone <remote>'
    cd - > /dev/null || return 1
    return
  fi

  
  local local_ref remote_ref
  local_ref=$(issue_ref)
  remote_ref=$(remote_issue_ref "$remote")

  # git fetch "${opts[@]}" "$remote" \
  #   "$(issue_ref):$(remote_issue_ref "$remote")"
  git fetch "$remote" \
    "$(issue_ref):$(remote_issue_ref "$remote")"

  #git worktree add .issues $remote/issues/latest && cd .issues && git update-ref "$local_ref" HEAD
  git worktree add .issues "$remote_ref" && cd .issues && git update-ref "$local_ref" HEAD && git update-ref "$local_ref" "$remote_ref"

  cd - > /dev/null || return 1
  return
}

#! TODO: config.worktree, core.bar, core.worktree
git_issue_init() {
  root="$(git_project_root)"
  wt="$(git_issue_worktree)"

  [ -d "$wt" ] && {
    remote=${remote:-$(resolve_issue_remote)}
    echo ".issues already exists. Use the following to remove it"
    echo ""
    echo "  git worktree remove $wt # To remove forcefully, use --force"
    echo "  git update-ref -d $(issue_ref)"
    echo "  git update-ref -d $(remote_issue_ref "$remote")"

    return 1
  }
  
  CLONE=ask
  if [ $# -gt 0 ]; then
    for i in "$@"; do
      case $i in
        --no-clone|-n)
          CLONE=false
          ;;
        --clone|-c)
          CLONE=true
          ;;
        *)
          # Handle unknown options or positional arguments
          echo '!W: Unknown option: '"$i"
          ;;
      esac
    done
  fi

  #remote="$1"
  remote=$(resolve_issue_remote)

  local wt
  wt=$(git_issue_worktree)

  local local_ref remote_ref
  local_ref="$(issue_ref)"
  remote_ref="$(remote_issue_ref "$remote")"

  #echo ".issues/" >> "$root/.git/info/exclude"
  echo ".issues/" >> "$root/.gitignore"

  if git ls-remote --exit-code "$remote" "$local_ref" > /dev/null 2>&1; then
    # ref exists on the remote
    echo '!W: The reference '"$local_ref"' exists on the remote('"$remote"').'
    if [ $CLONE = "ask" ]; then
      while true; do
        read -p '  - Do you want to clone it? (Y/N) ' ans
        case "$ans" in
          [Yy])
            CLONE=true
            break
            ;;
          [Nn])
            CLONE=false
            break
            ;;
        esac
      done
    fi
    
    
    if [ $CLONE = "true" ]; then
      # Possibly post-commit hook for auto-sync issue-status(open->closed)
      git_issue_clone "$remote"
      git config --local extensions.worktreeConfig true || echo 'FAILED: git config --local extensions.worktreeConfig true'
      cd "$wt" && {
        git config --worktree advice.detachedHead false
        #git config --worktree core.worktree "$wt"
        git config --worktree core.hooksPath /dev/null || echo 'FAILED: git config --worktree core.hooksPath /dev/null'

        # mkdir -p "$(git rev-parse --git-dir)/info"
        # echo ".local-repo-id" >> "$(git rev-parse --git-dir)/info/exclude"
        #echo ".gitignore" >> .gitignore
        #echo ".local-repo-id" >> .gitignore
      }
      cd - > /dev/null || return 1
      return
    fi
  fi

  #: since git worktree add --orphan is used, no more needed?
  #  if git rev-parse --verify HEAD >/dev/null 2>&1; then
  #    has_commit=1
  #  else
  #    has_commit=0
  #    echo "Needs at least one commit before git issue init"
  #    return 0
  #  fi

  # Create orphan detached worktree
  # git worktree add --detach "$root/.issues"
  # cd "$root/.issues" || return 1

  # Platform-agnostic timestamp generation
  if command -v gdate >/dev/null 2>&1; then
    # macOS with GNU coreutils installed
    timestamp=$(gdate +%s)
  elif date +%s >/dev/null 2>&1; then
    # Linux or macOS with recent date
    timestamp=$(date +%s)
  else
    # Fallback for older systems
    timestamp=$(perl -e 'print time')
  fi
  
  tmp_ref="refs/issues/tmp/${timestamp}-$$"
  #git worktree add --orphan -B temp_issues $root/.issues
  git worktree add --orphan -B "$tmp_ref" "$root/.issues"

  mkdir -p "$root/.issues/issues"

  git config --local extensions.worktreeConfig true || echo 'FAILED: git config --local extensions.worktreeConfig true'
  cd "$wt" || {
    echo "failed to cd to issue worktree"
    return 1
  }
  git config --worktree advice.detachedHead false
  #git config --worktree core.worktree "$wt"
  git config --worktree core.hooksPath /dev/null || echo 'FAILED: git config --worktree core.hooksPath /dev/null'

  # echo ".local-repo-id" >> "$(git rev-parse --git-dir)/info/exclude"  # This can not be applied when `git issue clone` unless `git issue init` is always done before `git issue clone`
  cat > .gitignore << 'EOF'
# Ignore everything in .issues/ except TEMPLATE.md 
.local-repo-id
github/
#TEMPLATE*.md
#!TEMPLATE*.md/
EOF

  cat > TEMPLATE.md << 'EOF'
---
title:
type: bug|feature|task|meta
status: open|in-progress|closed
priority: P1|P2|P3
severity: critical|high|medium|low
---

## Description

## Steps to Reproduce

## Expected Behavior

## Notes
EOF

  #  cp TEMPLATE.md .issues/TEMPLATE.md

  #  cat > issues/0001.md <<'EOF'
  #---
  #title: Initial issue tracking setup
  #type: meta
  #priority: low
  #---
  #
  #Issue tracking initialized.
  #EOF

  git add .
  git commit -m "issue init: templates loaded"
  commit=$(git rev-parse HEAD)

  #git update-ref "$ISSUE_REF_PREFIX/$issue_id"
  git update-ref refs/issues/latest "$commit"

  echo "Initialized issue tracking in .issues/"

  git checkout --detach
  #git branch -D temp_issues
  git branch -D "$tmp_ref"
  cd - > /dev/null || {
    echo "failed to restore the directory"
    return 1
  }
}

parse_issue_id() {
  local id="$1"
  local id_left id_right

  if echo "$id" | grep -q '-'; then
    # Normalize ID format
    id_left="${id%-*}"
    id_right="${id#*-}"
    #echo "$id_left" "$id_right"
    
    if [ "$id_left" = "$id_right" ]; then
      echo 'usage: git issue edit <id>'
      echo '  <id> should be alphabets-integers like PACMAN-0012, PACMAN-12, or PACMAN12'
      return 1
    fi

    if ! is_int "$id_right"; then
      echo 'usage: git issue edit <id>'
      echo '  <id> should be alphabets-integers like PACMAN-0012, PACMAN-12, or PACMAN12'
      return 1
    fi
  else
    # Extract alphabetic prefix and numeric suffix without regex
    # Remove all digits from the end to get prefix
    id_left="$id"
    while [ "$id_left" != "${id_left%[0-9]}" ]; do
      id_left="${id_left%[0-9]}"
    done
    
    # Remove all non-digits from the beginning to get suffix
    id_right="$id"
    while [ "$id_right" != "${id_right#[!0-9]}" ]; do
      id_right="${id_right#[!0-9]}"
    done
    
    # Validate that we have both parts
    if [ -z "$id_left" ] || [ -z "$id_right" ]; then
      echo "usage: git issue edit <id>"
      echo '  <id> should be alphabets-integers like PACMAN-0012, PACMAN-12, or PACMAN12'
      return 1
    fi
    
    # Verify id_left contains only alphabets and id_right contains only digits
    case "$id_left" in
      *[!A-Za-z]*)
        echo "usage: git issue edit <id>"
        echo '  <id> should be alphabets-integers like PACMAN-0012, PACMAN-12, or PACMAN12'
        return 1
        ;;
    esac
    
    case "$id_right" in
      *[!0-9]*)
        echo "usage: git issue edit <id>"
        echo '  <id> should be alphabets-integers like PACMAN-0012, PACMAN-12, or PACMAN12'
        return 1
        ;;
    esac
  fi

  #echo "$id_left" "$id_right"
  
  # Remove leading zeros - platform agnostic
  id_right=$(echo "$id_right" | sed 's/^0*//')
  
  # Handle empty string (if input was all zeros like "0000")
  [ -z "$id_right" ] && id_right="0"
  
  # Format with leading zeros (converts to decimal, avoiding octal interpretation)
  id_right=$(printf "%04d" "$id_right")
  #echo "$id_left" "$id_right"

  id="$id_left"-"$id_right"
  echo "$id"
}

git_issue_edit() {
  [ $# -eq 0 ] && { echo "usage: git issue comment <issue id>"; return 1; } 

  #echo gie1
  id="$(parse_issue_id "$1")" || return 1

  #echo gie2
  fn_md="$id".md
  root=$(git_project_root)
  wt=$(git_issue_worktree)
  path="$wt"/issues/"$fn_md"
  
  if ! safe_cd "$wt"; then
    echo '!E: '"Could not change directory to $wt"
    return 1
  fi

  #fn=$1
  [ -z "$id" ] && {
    echo "usage: git issue edit <id>"
    cd - > /dev/null || return 1
    return 1
  }

  [ -f "$path" ] || {
    echo "Issue $id not found"
    cd - > /dev/null || return 1
    return 1
  }

  # if ! is_int "$id"; then echo 'usage: git issue show <id>'; echo '  <id> should be an integer'; return 1;
  # else
  #   id=$(printf "%04d" $id)
  # fi

  tmpfile="$(mktemp)"".md"
  trap 'rm -f "$tmpfile"' EXIT INT TERM

  cp "$path" "$tmpfile"

  editor=$(git var GIT_EDITOR) || {
    rm -f "$tmpfile"
    trap - EXIT INT TERM
    cd - > /dev/null || return 1
    return 1
  }


  #${EDITOR:-vi} "$path"
  sh -c "$editor \"$tmpfile\"" || {
    echo "editor failed"
    rm -f "$tmpfile"
    trap - EXIT INT TERM
    cd - > /dev/null || return 1
    return 1
  }  

  echo $tmpfile
  
  # message="$(
  # sed \
  #   -e "s/[[:space:]]*$//" \
  #   "$tmpfile" \
  # | sed '/./,$!d' \
  # | awk 'NF {p=1} p; END {while (sub(/\n$/,"")) {}}' 
  # )"

  if cmp -s "$tmpfile" "$wt/TEMPLATE.md"; then 
    echo "- Just template. Aborted."
    cd - > /dev/null || return 1
    return 1
  elif cmp -s "$tmpfile" "$path"; then 
    echo "- Nothing changed. Aborted."
    cd - > /dev/null || return 1
    return 1
  else
    mv $tmpfile $path
    echo "- Saved to issue id $id"
    cd - > /dev/null || return 1
    return 0
  fi


  # if cmp -s "$path" "$root/.issues/TEMPLATE.md"; then
  #   echo "No changes made to issue $path"
  #   read -p "Do you want to keep the file? (Y/n): " ans
  #   case "$ans" in
  #     [Nn]*)
  #       rm -f "$path"
  #       echo "Deleted template issue file $path"
  #       ;;
  #     *)
  #       echo "Keeping template issue file $path"
  #       ;;
  #   esac
  # else
  #   return 0
  # fi
  
  
}

git_issue_comment() {
  [ $# -eq 0 ] && { echo "usage: git issue comment <issue id> [[-m|--message]=]"; return 1; }

  message_next=fasle
  for arg in "$@"; do
    case "$arg" in
      --message=*|-m=*)
        MSG_CLI="${arg#*=}"
        ;;
      --message|-m)
        message_next=true
        ;;
      --help)
        echo "usage: git issue comment <issue id> [[-m|--message]=]" 
        return 1
        ;;
      *)
        if [ "$message_next" = "true" ]; then
          MSG_CLI="$arg"
        else
          id=${id:-}
          if [ -z "$id" ]; then
            id="$arg"
          else
            echo "usage: git issue comment <issue id> [[-m|--message]=]"; return 1;
          fi
        fi
        ;;
    esac
  done
  

  id="$(parse_issue_id "$1")" || return 1
  fn_md="$id".md
  root=$(git_project_root)
  wt=$(git_issue_worktree)
  path="$wt"/issues/"$fn_md"
  
  if ! safe_cd "$wt"; then
    return 1
  fi

  #fn=$1
  [ -z "$id" ] && {
    echo "usage: git issue comment <issue id>"
    cd - > /dev/null || return 1
    return 1
  }

  [ -f "$path" ] || {
    echo "Issue $id not found"
    cd - > /dev/null || return 1
    return 1
  }

  if ! comment_char=$(git config core.commentChar); then
    comment_char="${comment_char:-#}"
  fi

  echo "- comment character set to $comment_char"

  tmpfile="$(mktemp)"".md"
  trap 'rm -f "$tmpfile"' EXIT INT TERM

  #sed 's/^/# /' file.txt > "$tmpfile"
  sed 's/^/'"$comment_char "'/' "$path" >> "$tmpfile"
  #echo '# --- >8 ISSUE '"$id"' ---' >> "$tmpfile"

  DIR_COMMENT="$wt/issues/$id/comments"
  echo "- comment directory : $DIR_COMMENT"
  comment_file=$(new_filename_comment .md "$id") || { 
    echo '!E: New comment name could not be created'
    rm -f "$tmpfile"
    trap - EXIT INT TERM
    cd - > /dev/null || return 1
    return 1
  }
  echo '- new comment file named '"$comment_file"

  mkdir -p "$DIR_COMMENT"
  find "$DIR_COMMENT" -type f -print0 2>/dev/null |
  while IFS= read -r -d '' other_comment_file; do
      {
        echo '' 
        echo '# --- >8 COMMENT '"$other_comment_file"' ---' 
        sed 's/^/'"$comment_char "'/' "$other_comment_file" 
        echo '' 
      } >> "$tmpfile"
  done

  echo '' >> "$tmpfile"
  user=$(git config user.name)
  email=$(git config user.email)
  
  # Platform-agnostic date formatting
  if date "+%Y-%m-%d %H:%M:%S" >/dev/null 2>&1; then
    t_now=$(date "+%Y-%m-%d %H:%M:%S")
  else
    # Fallback for systems with limited date support
    t_now=$(date)
  fi

  echo '*** comment by '"$user($email) at $t_now" >> "$tmpfile"

  MSG_CLI=${MSG_CLI:-}
  if [ -z "$MSG_CLI" ]; then 
    
    editor=$(git var GIT_EDITOR) || {
      rm -f "$tmpfile"
      trap - EXIT INT TERM
      cd - > /dev/null || return 1
      return 1
    }

    #${EDITOR:-vi} "$tmpfile"
    sh -c "$editor \"$tmpfile\"" || {
      echo '!'"W: editor failed"
      rm -f "$tmpfile"
      trap - EXIT INT TERM
      cd - > /dev/null || return 1
      return 1
    }
  
  else
    #echo "" >> "$tmpfile"
    echo "" >> "$tmpfile"
    echo "$MSG_CLI" >> "$tmpfile"
  fi

  # sed '/^'"$comment_char"'/d' "$tmpfile" > "$comment_file"
  # if [ -s "$comment_file" ]; then
  #   echo "- comment file saved to $comment_file"
  # else
  #   echo "- no comment to save. aborted"
  # fi
  
  message="$(
  sed \
    -e "s/[[:space:]]*$//" \
    -e "/^""$comment_char""[[:space:]]./d" \
    -e "/^""$comment_char""$/d" \
    "$tmpfile" \
  | sed '/./,$!d' \
  | awk 'NF {p=1} p; END {while (sub(/\n$/,"")) {}}' 
  )"

  echo "- message : $message"

  # shellcheck disable=SC2001
  message_trimmed="$(echo "$message" | sed 's/[*][*][*] comment by .* at .*$//')"

  if [ -z "$message_trimmed" ]; then
    echo "Aborted: empty message" >&2
    rm -f "$tmpfile"
    trap - EXIT INT TERM
    cd - > /dev/null || return 1
    return 1
  fi
  
  # Save result
  echo "- comment_file : $comment_file"
  printf "%s\n" "$message" > "$DIR_COMMENT"/"$comment_file" && echo "- comment file saved to $comment_file"

  
  # if cmp -s "$path" "$root/.issues/TEMPLATE.md"; then
  #   echo "No changes made to issue $path"
  #   printf "Do you want to keep the file? (Y/n): "
  #   read -r ans
  #   case "$ans" in
  #     [Nn]*)
  #       rm -f "$path"
  #       echo "Deleted template issue file $path"
  #       ;;
  #     *)
  #       echo "Keeping template issue file $path"
  #       ;;
  #   esac
  # else
  #   return 0
  # fi
  
  rm -f "$tmpfile"
  trap - EXIT INT TERM
  cd - > /dev/null || return 1
}
git_issue_new() {
  root=$(git_project_root)
  # cd "$root/.issues" || return 1
  wt=$(git_issue_worktree)
  if ! safe_cd "$wt"; then
    echo '!E:'" Could not change directory to $wt"
    return 1
  fi

  # Initialize variables with defaults
  TITLE=""
  BODY=""
  TYPE=""
  STATUS=""
  PRIORITY=""

  # Loop through all arguments
  for i in "$@"; do
    case $i in
      --title=*)
        # Use parameter expansion to strip "--title=" from the front
        TITLE="${i#*=}"
        shift # move past the argument
        ;;
      --body=*)
        BODY="${i#*=}"
        shift
        ;;
      --type=*)
        TYPE="${i#*=}"
        shift # move past the argument
        ;;
      --status=*)
        STATUS="${i#*=}"
        shift # move past the argument
        ;;
      --priority=*)
        PRIORITY="${i#*=}"
        shift # move past the argument
        ;;
      *)
        # Handle unknown options or positional arguments
        # echo "Unknown option: $i"
        ;;
    esac
  done

  fn_md=$(new_filename ".md") || {
    echo "failed to generate new filename"
    return 1
  }

  #echo 1
  root=$(git_project_root)
  path="$wt/issues/$fn_md"
  
  #echo 2
  mkdir -p "$(dirname "$path")"
  
  #echo 3
  # Validation (Optional)
  if [ -z "$TITLE" ]; then
    #echo 4
    [ -f "$path" ] || cp "$wt/TEMPLATE.md" "$path"
    id=$(basename "$fn_md" .md)
    #echo 5
    #echo "- id=$id"
    git_issue_edit "$id" || { return 1; }
    if [ -s "$path" ]; then
      echo '- issue '"$fn_md"' created'
    fi
    cd - > /dev/null || return 1
  else
    {
      echo "---"
      echo "title: $TITLE"
      [ -n "$TYPE" ] && echo "type: $TYPE"
      [ -n "$STATUS" ] && echo "status: $STATUS"
      [ -n "$PRIORITY" ] && echo "priority: $PRIORITY"
      echo "---"
      echo ""
      echo "$BODY"
    } > "$path"
    echo "Created new issue: issues/$fn_md"
    cd - > /dev/null || return 1
  fi

}

git_issue_commit() {
  root=$(git_project_root)

  local wt
  wt=$(git_issue_worktree)
  if ! safe_cd "$wt"; then
    return 1
  fi

  #if git diff --cached --quiet && git diff --quiet; then
  #  echo "No issue changes to commit"
  #  return 0
  #fi

  if issue_merge_in_progress; then
    echo "merge in progress; use git issue merge --continue"
    #git_issue_status;
    return 1
  fi

  git add issues

  #if [ -n "$1" ]; then
  #  git commit -m "$*"
  #else
  #  git commit
  #fi

  # git commit "$@"
  # [ $? -ne 0 ] && {
  #   echo "issue commit failed"
  #   git restore --staged issues/
  #   cd -
  #   return 1
  # }
  if ! git commit "$@"; then
    echo "issue commit failed"
    git restore --staged issues/
    cd -
    return 1
  fi

  git update-ref refs/issues/latest HEAD
  cd - || return 1
}

git_issue_log() {
  root="$(git_project_root)"
  wt=$(git_issue_worktree)
  if ! remote_tracking=$(git config --get issue.remote); then 
    remote_tracking=${remote_tracking:-$(resolve_issue_remote)}; 
  fi

  local audit=0

  for arg in "$@"; do
    case $arg in
      --audit)
        audit=1
        shift
        ;;
    esac
  done

  if ! safe_cd $wt; then
    #echo 'No .issue folder'
    echo "Issue worktree not yet initiated(.issues does not exist)" >&2
    echo "  - use 'git issue init' to create one" >&2
    return 1
  fi

  if ! git -C "$root/.issues" rev-parse refs/remotes/"$remote_tracking"/issues/latest >/dev/null 2>&1; then
    ref_remote_tracking=""
    # if ! git issue fetch "$remote_tracking"; then 
    #   echo '!E: git issue fetch '"$remote_tracking"' failed!'
    #   ref_remote_tracking=""
    # else
    #   ref_remote_tracking=refs/remotes/"$remote_tracking"/issues/latest
    # fi
  else
    ref_remote_tracking=refs/remotes/"$remote_tracking"/issues/latest
  fi

  if [[ $audit -eq 1 ]]; then

    #cd $wt && local_id=$(secure_repo_id)
    echo '> audit log'
    local_id="$(cat "$wt/.local-repo-id" 2> /dev/null)"
    # if [[ ! -f "$wt/.local-repo-id" ]]; then
    #   echo '!E: local-repo-id not found or can'\''t be generated'
    #   return 1
    # fi
    echo "- local-repo-id: $local_id"
    echo "- args: $@"

    git -C "$root/.issues" log --oneline --graph \
      --pretty=format:"%C(yellow)%h%C(reset) %C(magenta)%d%C(reset) %s" \
      --decorate \
      --decorate-refs=HEAD \
      --decorate-refs=refs/issues/latest \
      --decorate-refs=refs/remotes/"$remote_tracking"/issues/latest \
      --decorate-refs=refs/issues/audit/* \
      --decorate-refs-exclude=refs/heads/* \
      --glob='refs/issues/*' \
      $@ \
      HEAD refs/issues/latest $ref_remote_tracking
       #\
    #--decorate-refs=refs/issues/audit/"$local_id"
  else
    git -C "$root/.issues" log --oneline --graph \
      --decorate-refs=HEAD \
      --decorate-refs=refs/issues/latest \
      --decorate-refs=refs/remotes/"$remote_tracking"/issues/latest \
      --decorate-refs-exclude=refs/heads/* \
      $@ \
      HEAD refs/issues/latest $ref_remote_tracking 
       #\
    #--decorate-refs=refs/issues/audit/"$local_id"
  fi
  cd - >/dev/null || return 1
}

# git_issue_list() {
#   root=$(git_project_root)

#   [ ! -d "$root/.issues" ] && echo ".issue not found. Use \`git issue init\` to make one" && return 1
#   ls "$root/.issues/issues" | sed 's/\.md$//'
# }

count_comments() {
  # Count comment files
  id="$1"

  root=$(git_project_root)
  issues_dir="$root/.issues/issues" || return 1

  comments_dir="$issues_dir/$id/comments"
  if [ -d "$comments_dir" ]; then
    num_comments=$(find "$comments_dir" -type f | wc -l)
  else
    num_comments=0
  fi

  echo "$num_comments"
}

git_issue_show() {
  if [ $# -lt 1 ]; then
    echo '!E: Usage git issue show <id>' 
    return 1
  fi

  PRINT_COMMENTS=ask
  for arg in "$@"; do
    case "$arg" in
      --help)
        echo '- Usage: git issue show [--comments|--no-comments] <id>'
        return 1
        ;;
      --comments)
        PRINT_COMMENTS=true
        ;;
      --no-comments)
        PRINT_COMMENTS=false
        ;;
      *)
        id="$arg"
        ;;
    esac
  done

  id="$(parse_issue_id "$id")" || return 1
  id=${id%.md}
  [ -z "$id" ] && echo "usage: git issue show <id>" && return 1

  #if ! is_int "$id"; then echo 'usage: git issue show <id>'; echo '  <id> should be an integer'; return 1;
  #else
  #id=$(printf "%04d" $id)
  root=$(git_project_root)
  wt=$(git_issue_worktree)
  file="$root/.issues/issues/$id.md"

  [ -f "$file" ] || {
    echo "Issue $id not found"
    return 1
  }

  echo ''
  print_hline
  echo "ISSUE-FILE: issues/$id.md"
  sed -n '1,200p' "$file"
  #fi

  num_comments=$(count_comments "$id")
  print_hline
  echo "- Comments found : $num_comments"
  echo ""

  if [ "$num_comments" -gt 0 ]; then
    if [ $PRINT_COMMENTS = "ask" ]; then
      while :; do
        printf "%s" "--->8 Continue to comments? (Y/N) "
        read -r ans
        case "$ans" in
          [Nn])
            PRINT_COMMENTS=false
            break
            ;;
          [Yy])
            PRINT_COMMENTS=true
            break
            ;;
          *)
            # Invalid input, loop continues
            ;;
        esac
      done
    fi

    if [ $PRINT_COMMENTS = "false" ]; then
      return 0
    fi

    DIR_COMMENT="$wt/issues/$id/comments"

    if [ -d "$DIR_COMMENT" ]; then
      # Platform-agnostic approach using a temporary file for sorting
      tmp_sorted=$(mktemp)
      trap 'rm -f "$tmp_sorted"' EXIT INT TERM
      
      # Get files with modification times
      find "$DIR_COMMENT" -type f -print0 2>/dev/null | while IFS= read -r -d '' f; do
        # Get modification time in a platform-agnostic way
        if stat -f "%m" "$f" >/dev/null 2>&1; then
          # macOS (BSD stat)
          mtime=$(stat -f "%m" "$f")
        else
          # Linux (GNU stat)
          mtime=$(stat -c "%Y" "$f")
        fi
        printf "%s %s\n" "$mtime" "$f"
      done | sort -n | cut -d' ' -f2- > "$tmp_sorted"
      
      # Process each file (oldest to newest)
      while IFS= read -r other_comment_file; do
        [ -f "$other_comment_file" ] || continue
        echo '' 
        echo '=== >8 COMMENT '"$other_comment_file"' ---' 
        #cat "$other_comment_file" 
        sed 's/^/  /' "$other_comment_file"
        echo '' 
      done < "$tmp_sorted"
      
      rm -f "$tmp_sorted"
      trap - EXIT INT TERM
    fi
  fi
}



git_issue_list() {
  root=$(git_project_root)
  issues_dir="$root/.issues/issues" || return 1
  
  local filter_status=""
  local filter_type=""
  local sort_mode=""  # Initialize as empty to detect multiple calls

  # --- Argument Parsing ---
  
  
  while [[ "$#" -gt 0 ]]; do
    case $1 in
      --filter-status=*) filter_status="${1#*=}"; shift ;;
      --filter-type=*)   filter_type="${1#*=}"; shift ;;
      
      # Grouping Comment sorting aliases
      --sort-comments|--sort-comment|--sort-cmt)
        if [[ -n "$sort_mode" ]]; then
          echo "Error: Delete $1. Sort mode can be specified only once (already set to: $sort_mode)"
          return 1
        fi
        sort_mode="comments"
        shift 
        ;;

      # Grouping Priority sorting aliases
      --sort-priorities|--sort-priority|--sort-pri)
        if [[ -n "$sort_mode" ]]; then
          echo "Error: Delete $1. Sort mode can be specified only once (already set to: $sort_mode)"
          return 1
        fi
        sort_mode="priority"
        shift 
        ;;

      --open)   filter_status="open"; shift ;;
      --closed) filter_status="closed"; shift ;;
      *) shift ;; 
    esac
  done

  # Fallback to default sorting if none was specified
  [[ -z "$sort_mode" ]] && sort_mode="mtime"

  [ ! -d "$root/.issues" ] && echo ".issue not found..." && return 1
  
  # Temporary files for processing
  data_file=$(mktemp)
  trap 'rm -f "$data_file"' EXIT
  
  # 1. Collect all issue data into a pipe-delimited format
  find "$issues_dir" -maxdepth 1 -name "*.md" -type f | while IFS= read -r f; do
    if stat -f "%m" "$f" >/dev/null 2>&1; then
      mtime=$(stat -f "%m" "$f")
    else
      mtime=$(stat -c "%Y" "$f")
    fi
    
    id=$(basename "$f" .md)
    num_comments=$(count_comments "$id")
    
    # We use awk to output a single raw data line: mtime|id|status|type|pri|comments|title
    awk -v mtime="$mtime" -v id="$id" -v n_cmt="$num_comments" \
        -v target_status="$filter_status" -v target_type="$filter_type" '
      BEGIN { in_yaml = 0; title=type=pri=status="-" }
      /^---$/ { in_yaml = !in_yaml; next }
      in_yaml {
        if ($1 == "title:") { sub(/^title:[[:space:]]*/, ""); title = $0 }
        else if ($1 == "type:") { sub(/^type:[[:space:]]*/, ""); type = $0; gsub(/[[:space:](].*$/, "", type) }
        else if ($1 == "priority:") { pri = $2 }
        else if ($1 == "status:") { sub(/^status:[[:space:]]*/, ""); status = $0; gsub(/[[:space:](].*$/, "", status) }
      }
      END {
        match_status = (target_status == "" || status == target_status)
        match_type   = (target_type == "" || type == target_type)
        if (match_status && match_type) {
            # Output raw data separated by |
            printf "%s|%s|%s|%s|%s|%s|%s\n", mtime, id, status, type, pri, n_cmt, title
        }
      }
    ' "$f"
  done > "$data_file"

  # 2. Sort the data based on the requested mode
  # Column mapping: 1:mtime, 2:id, 3:status, 4:type, 5:pri, 6:comments, 7:title
  case $sort_mode in
    comments)
      # Sort by field 6 (comments) Numerically, Reverse
      sorted_data=$(sort -t'|' -k6,6nr "$data_file")
      ;;
    priority)
      # Sort by field 5 (priority) Alphanumerically (P1, P2...)
      sorted_data=$(sort -t'|' -k5,5 "$data_file")
      ;;
    *)
      # Default: Sort by field 1 (mtime) Numerically, Reverse
      sorted_data=$(sort -t'|' -k1,1nr "$data_file")
      ;;
  esac

  # 3. Print the Table
  printf "%-13s %-8s %-8s %-3s %-4s %s\n" "ID" "STATUS" "TYPE" "PRI" "#CMT" "TITLE"
  echo "$sorted_data" | while IFS='|' read -r mt id st ty pr cm ti; do
    [ -z "$id" ] && continue
    printf "%-13s %-8s %-8s %-3s %4d %s\n" \
      "$id" "${st:0:8}" "${ty:0:8}" "${pr:0:3}" "$cm" "$ti"
  done
}

upper() {
  printf "%s" "$1" | tr '[:lower:]' '[:upper:]'
}

truncate() {
  max=$1
  shift
  s="$*"
  [ "${#s}" -le "$max" ] && printf "%s" "$s" ||
    printf "%s…" "${s:0:max}"
}

rel_time() {
  delta=$1 # seconds

  if [ "$delta" -lt 3600 ]; then
    printf -- "<   %2dM" $((delta / 60 + 1))
  elif [ "$delta" -lt 86400 ]; then
    printf -- "<   %2dH" $((delta / 3600 + 1))
  elif [ "$delta" -lt 2592000 ]; then
    printf -- "<  %2dd " $((delta / 86400 + 1))
  elif [ "$delta" -lt 31536000 ]; then
    printf -- "< %2dm  " $((delta / 2592000 + 1))
  else
    printf -- "< %2dy  " $((delta / 31536000 + 1))
  fi
}

priority_char() {
  case "$1" in
    "P1") PRI_MAP="1 " ;;
    "P2") PRI_MAP=" 2 " ;;
    "P3") PRI_MAP="  3" ;;
    *) PRI_MAP="  ?" ;; # Default for unknown values
  esac

  echo "$PRI_MAP"
}

git_issue_list_full() {
  root=$(git_project_root)
  issues_rootdir="$root/.issues" || return 1
  issues_dir="$root/.issues/issues" || return 1
  wt=$(git_issue_worktree)
  if ! safe_cd "$wt"; then
    return 1
  fi # This is safter and the following cd
  # safe_cd "$issues_rootdir" || return 1

  #                 TYPE PRI  TITLE CHANGED
  printf "%-11s %-2s %-4s %-3s %-40s %-7s %-35s %s\n" \
    "ID" "ST" "TYPE" "PRI" "TITLE" "CHANGED" "COMMIT" "CMT_TIME"

  for f in "$issues_dir"/*.md; do
    [ -f "$f" ] || continue

    id=$(basename "$f" .md)
    rel="issues/$id.md"

    # -------- frontmatter --------
    # Read into variables without eval to avoid command injection
    while IFS= read -r line; do
      case "$line" in
        status:*)
          status="${line#status:}"
          status="${status#"${status%%[![:space:]]*}"}"
          ;;
        type:*)
          type="${line#type:}"
          type="${type#"${type%%[![:space:]]*}"}"
          ;;
        priority:*)
          pri="${line#priority:}"
          pri="${pri#"${pri%%[![:space:]]*}"}"
          ;;
        title:*)
          title="${line#title:}"
          title="${title#"${title%%[![:space:]]*}"}"
          ;;
      esac
    done < <(awk '
            BEGIN { in_yaml = 0 }
            /^---$/ { in_yaml = !in_yaml; next }
            in_yaml && /^(status|type|priority|title):/ { print }
        ' "$f")

    ST=$(upper "${status:-??}")
    ST=${ST:0:2}
    TYPE=$(upper "${type:-????}")
    TYPE=${TYPE:0:4}
    PRI=$(upper "${pri:-???}")
    PRI=${PRI:0:3}
    TITLE=$(truncate 39 "${title:-}")

    PRI_MAP=$(priority_char "$PRI")

    # -------- dirty / changed --------
    if git status --porcelain -- "$rel" | grep -q .; then
      now=$(date +%s)
      mtime=$(stat -c %Y "$f" 2> /dev/null || stat -f %m "$f")
      delta=$((now - mtime))
      CHANGED=$(rel_time "$delta")
    else
      CHANGED=""
    fi

    # -------- last commit --------
    read -r cdate ctime cmsg << EOF
$(git log -1 --pretty=format:'%cd %s' --date=format:'%Y-%m-%d %H:%M' -- "$rel" 2> /dev/null)
EOF

    COMMIT=$(truncate 34 "$cmsg")
    CMT_TIME=${cdate%:*}

    printf "%-11s %-2s %-4s %-3s %-40s %-7s %-35s %s\n" \
      "$id" "$ST" "$TYPE" "$PRI_MAP" "$TITLE" "$CHANGED" "$COMMIT" "$CMT_TIME"
  done | sort
  echo '==============================='
  echo '* '"CHANGED: relative time since last modification(uncommitted changes)"
  cd - > /dev/null || return 1
}

#git_issue_list_full

git_issue_search() {
  # for f in $(git issue search --title='[Tt]est'); do echo '========================='; echo '= '$f; echo ""; grep -C 5 -i Test $f; done
  local pat=
  local title_pat=
  local body_pat=
  local ignore_case=0

  root=$(git_project_root)
  issues_rootdir="$root/.issues" || return 1
  issues_dir="$root/.issues/issues" || return 1

  # parse args
  for arg in "$@"; do
    case $arg in
      --title=*) title_pat=${arg#*=} ;;
      --body=*) body_pat=${arg#*=} ;;
      -i) ignore_case=1 ;;
      *)
        pat=$arg
        ;;
    esac
  done

  #echo "$title_pat"
  #echo "$body_pat"
  #echo "$ignore_case"

  awk -v pat="$pat" \
    -v title_pat="$title_pat" \
    -v body_pat="$body_pat" \
    -v icase="$ignore_case" '

  function finish_file() {
    if (prev_filename == "") return
    match_file = 1

    # Case-insensitive preparation
    content_to_check = (icase ? tolower(body) : body)
    t_pat = (icase ? tolower(title_pat) : title_pat)
    b_pat = (icase ? tolower(body_pat) : body_pat)
    g_pat = (icase ? tolower(pat) : pat)

    # 1. Title Specific Filter
    if (title_pat != "") {
      found_title = 0
      for (k in yaml) {
        key_match = (icase ? tolower(k) : k)
        if (key_match == "title") {
          val_match = (icase ? tolower(yaml[k]) : yaml[k])
          if (val_match ~ t_pat) found_title = 1
        }
      }
      if (!found_title) match_file = 0
    }

    # 2. Body Specific Filter
    if (body_pat != "" && content_to_check !~ b_pat)
      match_file = 0

    # 3. Global pattern (check keys, values, AND body)
    if (pat != "") {
      dump = body
      for (k in yaml) dump = dump " " k " " yaml[k]
      if (icase) dump = tolower(dump)
      if (dump !~ g_pat) match_file = 0
    }

    if (match_file) print prev_filename 
  }  

  # Reset state and process previous file before starting new file
  FNR == 1 {
    if (NR > 1) finish_file()
    in_yaml = 0
    body = ""
    # Portable way to clear an array
    split("", yaml)
    prev_filename = FILENAME
  }

  # YAML parsing
  $0 == "---" {
    if (FNR == 1) { in_yaml = 1; next }
    if (in_yaml) { in_yaml = 0; next }
  }

  in_yaml {
    if (match($0, /^[a-zA-Z0-9_-]+:/)) {
      sep = index($0, ":")
      key = substr($0, 1, sep - 1)
      val = substr($0, sep + 1)
      # Trim both leading and trailing whitespace
      gsub(/^[[:space:]]+|[[:space:]]+$/, "", val)
      yaml[key] = val
    }
    next
  }

  # Everything else is body
  { body = body $0 "\n" }

  END { finish_file() }
' "$issues_dir"/*.md
}

#git_issue_search Hi

resolve_issue_remote() {
  # 1. explicit CLI remote already handled by caller

  # 2. issue.remote
  local r
  if r=$(git config --get issue.remote); then
    echo "$r"
    return
  fi

  # 3. remote.pushDefault
  if r=$(git config --get remote.pushDefault); then 
    echo "$r"
    return
  fi

  # 4. branch upstream (only if on branch)
  local branch
  root=$(git_project_root); cd "$root" > /dev/null 2>&1 || return 1
  if branch=$(git symbolic-ref --quiet --short HEAD 2> /dev/null); then
    if r=$(git config --get branch."$branch".remote); then
      echo "$r"
      return
    fi
  fi 

  cd - > /dev/null 2>&1 || return 1

  # 5. fallback
  echo origin
}

# git_issue_remote() {
#   git config issue.remote 2>/dev/null ||
#   git config --get remote.pushDefault ||
#   echo origin
# }

git_issue_track() {
  #[ $# -eq 1 ] || { echo "usage: git issue track <remote>"; return 1; }
  if [ "$#" -gt 1 ]; then
    echo "usage: git issue track (<remote>|--unset)"
    return 1
  fi

  if [ "$#" -lt 1 ]; then
    #echo "usage: git issue track <remote>"

    # from function resolve_issue_remote
    local r
    if r=$(git config --get issue.remote); then
      echo "Currently tracking $r"
      return
    fi

    echo "Tracking remote is not set."

    # 3. remote.pushDefault
    if r=$(git config --get remote.pushDefault); then
      echo "- remote.pushDefault set to $r"
      return
    fi
    
    # 4. branch upstream (only if on branch)
    local branch
    if branch=$(git symbolic-ref --quiet --short HEAD 2> /dev/null); then
      if r=$(git config --get branch.$branch.remote); then
        echo "- branch.CURRENT_BRANCH($branch).remote set to $r"
        return
      fi
    fi

    # 5. fallback
    echo "- remote would be origin if not specified"

    return 1
  fi

  if [ "$#" -eq 1 ]; then
    local remote=$1

    if [ "$remote" = "--unset" ]; then
      git config --unset issue.remote ||
        {
          echo "failed to unset issue.remote"
          return 1
        }
    fi

    # check remote exists
    if ! git ls-remote --exit-code "$remote" > /dev/null 2>&1; then
      echo "remote '$remote' not found"
      return 1
    fi

    git config issue.remote "$remote" ||
      {
        echo "failed to set issue.remote"
        return 1
      }

    echo "Issues now track remote '$remote'"
  fi
}

# Original
# git_issue_push() {
#   local remote=
#   local opts=()

#   remote=$(git config --get remote.pushDefault || echo origin)

#   for arg in "$@"; do
#     case "$arg" in
#       --force|-f)
#         echo "force-push is forbidden for issues"
#         return 1
#         ;;
#       -*)
#         opts+=("$arg")
#         ;;
#       *)
#         remote="$arg"
#         ;;
#     esac
#   done

#   git push "${opts[@]}" "$remote" \
#     refs/issues/latest:refs/issues/latest
# }

git_issue_push() {
  local set_upstream=0
  local force=0
  local remote=

  while [ $# -gt 0 ]; do
    case "$1" in
      -u) set_upstream=1 ;;
      #--force|-f) force=1 ;;
      *) remote=$1 ;;
    esac
    shift
  done

  if [ $set_upstream -eq 1 ] && [ -z "$remote" ]; then
    echo "remote must be specified when using -u"
    return 1
  fi

  remote=${remote:-$(resolve_issue_remote)}
  url_remote="$(git remote get-url --push "$remote")"

  if [[ ! ("$url_remote" =~ ^file:// ||
    "$url_remote" =~ ^ssh:// ||
    "$url_remote" =~ ^git:// ||
    "$url_remote" =~ ^https:// ||
    "$url_remote" =~ ^http://) ]]; then

    if ! is_git_scp_like_host_path "$url_remote"; then # not scp-like
      if [[ ! "$url_remote" = /* ]]; then              # not absolute path
        local root
        root="$(git_project_root)"
        echo '!W: Relative local paths would not work for worktree.'
        echo '    If it failes, try delete and create '"$remote"' again using the following:'
        echo '    - git remote remove '"$remote"
        echo '    - git remote add '"$remote"' '"$(realpath "$root"/"$url_remote")"
        echo '    - git issue push '"$remote"
      else
        echo '!W: Your remote may be ambiguous whether it is scp or local path'
        echo '    If it failes, try ssh:// or file://'"$url_remote"
      fi
    fi
  fi
  echo 'Pushing issues to remote '"$remote"'...'

  local L R
  L=$(issue_ref)
  R=$(remote_issue_ref "$remote")

  # ! replace die
  #   replace die "([^"]+)"
  #   with { echo "$1"; return 1; }

  # ensure local ref exists
  git show-ref --verify --quiet "$L" ||
    {
      echo "no local issue snapshot ($L)"
      return 1
    }

  # fetch remote state for safety check
  # git_issue_fetch "$remote"
  #commnted: isolate fetch from push

  if [ $force -eq 0 ] && git show-ref --verify --quiet "$R"; then
    git merge-base --is-ancestor "$R" "$L" ||
      {
        echo "remote issues have advanced; do "git issue fetch" first"
        return 1
      }
  fi

  if git push "$remote" "$L:$L"; then
    echo "- Push successful"
    if git_issue_fetch "$remote"; then
      echo "- Local snapshot updated"
    else
      echo "- Failed to update local snapshot"
    fi
  else
    echo "- Push failed"
    return 1
  fi

  if [ $set_upstream -eq 1 ]; then
    git config issue.remote "$remote"
    echo "Tracking remote set to '$remote'"
  fi
}

git_issue_fetch() {
  #set -x
  local remote=
  local opts=()

  for arg in "$@"; do
    case "$arg" in
      -*)
        opts+=("$arg")
        ;;
      *)
        remote="$arg"
        ;;
    esac
  done

  if ! remote=${remote:-$(resolve_issue_remote)}; then
    echo '!E: No remote and no default'
    echo '- Usage: git issue fetch <remote>'
    return 1
  fi

  local local_ref remote_ref
  local_ref=$(issue_ref)
  remote_ref=$(remote_issue_ref "$remote")

  # issue_git show-ref --verify --quiet "$local_ref" \
  #   || { echo "no local issue snapshot"; return 1; }

  # issue_git show-ref --verify --quiet "$remote_ref" \
  #   || { echo "no remote issue snapshot for '$remote'"; return 1; }

  REMOTE_SHA=$(git ls-remote "$remote" "$local_ref" | cut -f1)
  if [ -z "$REMOTE_SHA" ]; then
    echo "remote issue snapshot not found on '$remote'"
    return 1
  fi



  if LOCAL_SHA=$(git rev-parse "$remote_ref" 2> /dev/null); then
  #echo "$REMOTE_SHA"

    if [ "$LOCAL_SHA" = "$REMOTE_SHA" ]; then
      echo "Nothing to fetch: local remote-tracking issue snapshot is up-to-date with '$remote'"
      return 0
    fi
  fi

  git fetch "${opts[@]}" "$remote" \
    "$(issue_ref):$(remote_issue_ref "$remote")" ||
    {
      echo "fetch failed"
      return 1
    }
}

# clone-issue workflow:
# 1. git issue fetch
# 2. git worktree add .issues/ origin/issues/latest
# 3. git issue list

issue_merge_in_progress() {
  issue_git rev-parse -q --verify MERGE_HEAD > /dev/null 2>&1
}

git_issue_merge() {
  local mode=
  local rebase=0
  local remote=
  local opts=()
  local audit=0

  for arg in "$@"; do
    case "$arg" in
      --help)
        echo '- Usage: git issue merge [--rebase] [--audit]'
        echo '  - Start merging remote and current HEAD.'
        echo '     --rebase: use rebase if possible'
        echo '     --audit:  leave a tag for audit'
        echo ''
        echo '- Usage: git issue merge [--continue|--abort]'
        echo '  - Continue or abort merge(or rebase) while in conflict'
        echo '     --continue: continue merging after resolving conflicts manually'
        echo '     --abort: abort the merging after conflicts'
        ;; 
      --abort)
        if [ "$mode" = "--continue" ]; then
          echo "cannot use --abort and --continue together"
          return 1
        fi
        mode="--abort"
        ;;
      --continue)
        mode="--continue"
        if [ "$mode" = "--abort" ]; then
          echo "cannot use --abort and --continue together"
          return 1
        fi
        mode="--continue"
        ;;
      --rebase)
        rebase=1
        ;;
      --audit)
        audit=1
        ;;
      -*)
        opts+=("$arg")
        ;;
      *)
        remote="$arg"
        ;;
    esac
  done

  #remote=$(git_issue_remote)
  remote=${remote:-$(resolve_issue_remote)}

  local wt
  wt=$(git_issue_worktree)

  local local_ref remote_ref
  local_ref=$(issue_ref)
  remote_ref=$(remote_issue_ref "$remote")

  issue_git show-ref --verify --quiet "$local_ref" ||
    {
      echo "no local issue snapshot"
      return 1
    }

  issue_git show-ref --verify --quiet "$remote_ref" ||
    {
      echo "no remote issue snapshot for '$remote'"
      return 1
    }

  (
    cd "$wt" || {
      echo "failed to enter issue worktree $wt"
      return 1
    }

    case $mode in
      --abort)
        #git rebase --abort 2>/dev/null || git merge --abort
        git merge --abort
        return 0
        ;;
      --continue)
        if [ -f "$(git rev-parse --git-dir)"/MERGE_HEAD ]; then
          git add issues
          git commit || {
            echo "commit failed"
            return 1
          }
          git update-ref "$local_ref" HEAD
          return 0
        else
          echo "no merge to continue"
          return 1
        fi
        ;;
    esac

    #git fetch "$remote" \
    #  "refs/issues/latest:$remote_ref" || die "fetch failed"

    local local_oid remote_oid
    local_oid=$(git rev-parse "$local_ref")
    remote_oid=$(git rev-parse "$remote_ref")

    # Fast-forward?
    if git merge-base --is-ancestor "$local_oid" "$remote_oid"; then
      # git reset --hard "$remote_oid"

      new_opts=()
      local ff=1
      for opt in "${opts[@]}"; do
        #if [[ "$opt" != "--ff" && "$opt" != "--no-ff" ]]; then
        #  new_opts+=("$opt")
        if [[ "$opt" = "--ff" ]]; then
          ff=1
        elif [[ "$opt" = "--no-ff" || "$opt" = "ff-only" ]]; then
          ff=0
          new_opts+=("$opt")
        fi
      done
      opts=("${new_opts[@]}")

      if [[ $ff -eq 1 ]]; then
        git merge --ff "${opts[@]}" "$remote_oid"
      else
        git merge "${opts[@]}" "$remote_oid"
      fi

      git update-ref "$local_ref" HEAD
      return 0
    fi

    #output=$(git rebase "$remote_oid" 2>&1)
    #if [ $? -eq 0 ]; then
    if [[ $audit -eq 1 ]]; then
      # to preserve the original commits
      ref_audit="$(issue_audit_ref)"/pre-rebase-"$(date +%y%m%d%H%M)"
      git update-ref "$ref_audit" HEAD
    fi
    if [[ $rebase -eq 1 ]]; then
      if output=$(git rebase "$remote_oid" 2>&1); then
        echo "$output"
        git update-ref "$local_ref" HEAD

        return 0
      else
        echo "rebase failed, falling back to merge..."
        git update-ref -d "$ref_audit"
        git rebase --abort > /dev/null 2>&1
        if git merge "${opts[@]}" "$remote_oid"; then
          git update-ref "$local_ref" HEAD
          return 0
        fi
      fi
    else
      if output=$(git merge "$remote_oid" 2>&1); then
        echo "$output"
        git update-ref "$local_ref" HEAD
        return 0
      fi
    fi

    # # Try rebase
    # if git rebase "$remote_oid"; then
    #   git update-ref "$local_ref" HEAD
    #   return 0
    # fi

    # # Rebase failed → fallback to merge
    # git rebase --abort

    # if git merge "${opts[@]}" "$remote_oid"; then
    #   git update-ref "$local_ref" HEAD
    #   return 0
    # fi

    echo "git-issue> Conflict detected. Resolve and run:"
    echo "             git issue merge --continue"
    echo "             git issue merge --abort"
    return 1
  )
}

git_issue_status() {
  local wt
  wt=$(git_issue_worktree)

  (
    #cd "$wt" 2> /dev/null || { echo 'E: .issues not yet initiated.'; echo '  - use "git issue init" and "git issue pull"'; return 1; }
    if ! safe_cd "$wt"; then
      return 1
    fi

    issue_gitdir=$(git rev-parse --git-dir)
    if [ -f "$issue_gitdir"/MERGE_HEAD ]; then
      echo "Issue merge in progress"
      git status --short 
      exit 0
    fi

    #if git diff-index --quiet HEAD -- || \
    #  [ -n "$(git ls-files --others --exclude-standard)" ]; then
    #  echo "Repository has changes or untracked files"
    #fi

    local remote_tracking
    #remote=$(git_issue_remote)
    if ! remote_tracking=$(git config --get issue.remote); then 
      remote_tracking=${remote_tracking:-$(resolve_issue_remote)}; fi
    if [ -n "$remote_tracking" ]; then
      #echo "$remote_tracking"

      local local_oid remote_oid
      local_oid=$(git rev-parse "$(issue_ref)")
      #remote_oid=$(git rev-parse "$(remote_issue_ref "$remote_tracking")" 2>/dev/null)
      if ! remote_oid=$(git rev-parse "$(remote_issue_ref "$remote_tracking")" 2> /dev/null); then
        echo "No remote issue snapshot for '$remote_tracking'"
        #return 1
      elif [ -n "$remote_oid" ]; then
        if [ "$local_oid" = "$remote_oid" ]; then
          echo "Issues up to date with tracking remote $remote_tracking"
        elif git merge-base --is-ancestor "$local_oid" "$remote_oid"; then
          printf "Issues behind tracking remote $remote_tracking by %s commits\n" \
            "$(git rev-list --count "$local_oid..$remote_oid")"
        elif git merge-base --is-ancestor "$remote_oid" "$local_oid"; then
          printf "Issues ahead of tracking remote $remote_tracking by %s commits\n" \
            "$(git rev-list --count "$remote_oid..$local_oid")"
        else
          printf "Issues diverged: Ahead %s, Behind %s\n" \
            "$(git rev-list --count "$remote_oid..$local_oid")" \
            "$(git rev-list --count "$local_oid..$remote_oid")"
        fi
      fi
    else
      echo "No tracking remote set for issues"
    fi

    # if git diff-index --quiet HEAD -- || \
    #   [ -n "$(git ls-files --others --exclude-standard)" ]; then
    #   echo "No changes since last commit"
    # else
    git status --short -- issues/
    # fi
  )
}
